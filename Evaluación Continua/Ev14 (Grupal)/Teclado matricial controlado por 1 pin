#ifndef F_CPU
#define F_CPU 16000000UL
#endif
#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

/* ===== Config ===== */
#define ADC_CH      0
#define ADC_N       12
#define DBMS        35
#define HOLD        10
#define IDLE_D      3
#define ERR_OK      40

/* ===== LCD (RS=D8, EN=D9, D4..D7=PD4..PD7) ===== */
#define RS_PORT PORTB
#define RS_DDR  DDRB
#define RS_PIN  PB0
#define EN_PORT PORTB
#define EN_DDR  DDRB
#define EN_PIN  PB1
#define D_PORT  PORTD
#define D_DDR   DDRD

/* Etiquetas de teclas (A..D, col 1..4) */
static const char key[4][4] = {
  {'7','8','9','/'},
  {'4','5','6','x'},
  {'1','2','3','-'},
  {'C','0','=','+'}
};

/* ---------- LCD ---------- */
static void en_pulse(void){ EN_PORT|=(1<<EN_PIN); _delay_us(1); EN_PORT&=~(1<<EN_PIN); _delay_us(50); }
static void put4(uint8_t hi){ D_PORT=(D_PORT&0x0F)|hi; en_pulse(); }
static void lcd_cmd(uint8_t c){ RS_PORT&=~(1<<RS_PIN); put4(c&0xF0); put4((c<<4)&0xF0); if(c==0x01||c==0x02)_delay_ms(2); }
static void lcd_dat(uint8_t d){ RS_PORT|=(1<<RS_PIN);  put4(d&0xF0); put4((d<<4)&0xF0); }
static void lcd_xy(uint8_t x,uint8_t y){ static const uint8_t b[2]={0x00,0x40}; lcd_cmd(0x80|(b[y&1]+(x&0x0F))); }
static void lcd_put(const char*s){ while(*s) lcd_dat(*s++); }
static void lcd_num4(uint16_t v){ char b[5]; b[4]='\0'; for(int8_t i=3;i>=0;i--){ b[i]='0'+(v%10); v/=10; } lcd_put(b); }
static void lcd_init(void){
  RS_DDR|=(1<<RS_PIN); EN_DDR|=(1<<EN_PIN); D_DDR|=(1<<PD4)|(1<<PD5)|(1<<PD6)|(1<<PD7);
  RS_PORT&=~(1<<RS_PIN); EN_PORT&=~(1<<EN_PIN); _delay_ms(50);
  lcd_cmd(0x33); lcd_cmd(0x32); lcd_cmd(0x28); lcd_cmd(0x0C); lcd_cmd(0x06); lcd_cmd(0x01); _delay_ms(2);
}

/* ---------- ADC ---------- */
static void adc_init(void){ ADMUX=(1<<REFS0)|ADC_CH; ADCSRA=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); }
static uint16_t adc_one(void){ ADCSRA|=(1<<ADSC); while(ADCSRA&(1<<ADSC)); return ADC; }
static uint16_t adc_avg(void){ uint32_t s=0; for(uint8_t i=0;i<ADC_N;i++) s+=adc_one(); return (uint16_t)(s/ADC_N); }
static uint16_t press_get(uint16_t idle){
  uint16_t th = idle + IDLE_D, v=0;
  do{ v=adc_avg(); _delay_ms(HOLD); }while(v<=th);
  _delay_ms(DBMS); return adc_avg();
}
static void wait_rel(uint16_t idle){
  uint16_t th = idle + IDLE_D, v;
  do{ v=adc_avg(); _delay_ms(HOLD); }while(v>th);
}

/* ===== Modelo 1-pin ===== */
static const uint32_t rf[4] = {1000, 3300, 10000, 33000};  // filas
#define RPULL 10000U
// columnas: normal y con col 2<->3 intercambiadas
static const uint32_t rcA[4] = {2200, 6800, 22000, 68000};
static const uint32_t rcB[4] = {2200, 22000, 6800, 68000};

/* Tablas (cuentas ADC 0..1023) */
static void tbl_build(const uint32_t rc[4], uint16_t t[4][4]){
  for(uint8_t r=0;r<4;r++) for(uint8_t c=0;c<4;c++){
    uint32_t S = RPULL + rf[r] + rc[c];
    t[r][c] = (uint16_t)((1023UL*RPULL + S/2)/S);
  }
}

/* Decode usando ambos modelos; devuelve fila/col l칩gicas y car치cter */
static char decode(uint16_t x, uint8_t *ro, uint8_t *co, uint16_t *eo){
  uint16_t TA[4][4], TB[4][4]; tbl_build(rcA,TA); tbl_build(rcB,TB);
  uint16_t e=0xFFFF; uint8_t rr=0, cc=0, m=0;

  for(uint8_t r=0;r<4;r++) for(uint8_t c=0;c<4;c++){ // A
    uint16_t ref=TA[r][c], d=(x>ref)?(x-ref):(ref-x);
    if(d<e){ e=d; rr=r; cc=c; m=0; }
  }
  for(uint8_t r=0;r<4;r++) for(uint8_t c=0;c<4;c++){ // B (2<->3)
    uint16_t ref=TB[r][c], d=(x>ref)?(x-ref):(ref-x);
    if(d<e){ e=d; rr=r; cc=c; m=1; }
  }

  // Columna l칩gica: si gan칩 B, intercambia 2 y 3
  uint8_t cl = (m==1 ? (cc==1?2:(cc==2?1:cc)) : cc);
  if(ro) *ro=rr; if(co) *co=cl; if(eo) *eo=e;
  return key[rr][cl];
}
