.include "m328pdef.inc"


.cseg
.org 0x0000
    rjmp Inicio

Inicio:
    ; --- Stack ---
    ldi  r16, high(RAMEND)     ; ldi: carga inmediata
    out  SPH, r16              ; out: escribe en IO
    ldi  r16, low(RAMEND)
    out  SPL, r16

    ; --- GPIO ---
    sbi  DDRB, 0               ; PB0 salida (LED variable)
    sbi  DDRB, 5               ; PB5 salida (indica si se recibió la señal del botón)
    cbi  DDRD, 2               ; PD2 entrada
    cbi  DDRD, 3               ; PD3 entrada
    sbi  PORTD, 2              ; pull-up PD2
    sbi  PORTD, 3              ; pull-up PD3

    ; --- Timer0 /1024 ---
    ldi  r16, 0x05             ; CS02=1, CS01=0, CS00=1
    out  TCCR0B, r16
    ldi  r16, 0x00
    out  TCNT0, r16
    ldi  r16, 0x01
    out  TIFR0, r16            ; limpia TOV0 (Escribe 1 para limpiar)

    ; --- Estado inicial ---
    ldi  r25, 0x00             ; tiempo = 0x003D (?1 s)
    ldi  r24, 0x3D
    ldi  r21, 0x00             ; flags pulsación = 0

main:
    sbi  PORTB, 0              ; LED ON
    rcall espera_ajustable
    cbi  PORTB, 0              ; LED OFF
    rcall espera_ajustable
    rjmp main

espera_ajustable:
    mov  r27, r25              ; contador = tiempo (H)
    mov  r26, r24              ; contador = tiempo (L)
    ldi  r16, 0x01
    out  TIFR0, r16            ; reset TOV0

espera_loop:
    in   r16, TIFR0
    andi r16, 0x01             ; andi: enmascara bit TOV0
    breq espera_loop           ; breq: si Z=1, repetir (aún no hay overflow)
    ldi  r16, 0x01
    out  TIFR0, r16            ; reconoce overflow

    in   r16, PIND             ; lee PD3..PD0
    cbi  PORTB, 5              

    mov  r17, r16
    andi r17, 0x04             ; aísla PD2
    cpi  r17, 0x00             ; cpi: compara con 0
    brne inc_suelto            ; si ?0, está suelto -> liberar flag

    mov  r18, r21
    andi r18, 0x01             ; ¿flag INC ya contado?
    brne check_dec               ; sí -> no sumar de nuevo

    sbi  PORTB, 5              ; indicador ON
    ldi  r18, 0x0C             ; +paso 0,2s (12 ovf)
    add  r24, r18              ; suma en L
    ldi  r18, 0x00
    adc  r25, r18              ; acarreo en H

    ; Límiste MAX = 0x0400 (1024 ovf)
    ldi  r19, 0x04             ; Hmax
    ldi  r18, 0x00             ; Lmax
    cp   r25, r19              ; compara H
    brlo inc_ok                ; H < Hmax -> OK
    brne set_max_inc           ; H > Hmax -> saturar
    cp   r24, r18              ; H == Hmax -> compara L
    brlo inc_ok                ; L < Lmax -> OK
    breq inc_ok                ; L == Lmax -> OK
set_max_inc:
    mov  r25, r19              ; saturar a MAX
    mov  r24, r18
inc_ok:
    mov  r27, r25              ; recarga contador con nuevo tiempo
    mov  r26, r24              ; aplica inmediato
    ori  r21, 0x01             ; set flag INC (una vez por toque)
    rjmp check_dec

inc_suelto:
    andi r21, 0xFE             ; clear flag INC al soltar botón

check_dec:
    mov  r17, r16
    andi r17, 0x08             ; aísla PD3
    cpi  r17, 0x00
    brne dec_suelto           ; suelto -> liberar flag

    mov  r18, r21
    andi r18, 0x02             ; ¿flag DEC ya contado?
    brne dec_cont               ; sí -> no restar de nuevo

    sbi  PORTB, 5              ; indicador ON
    ldi  r18, 0x0C             ; ?paso 0,2s (12 ovf)
    sub  r24, r18
    ldi  r18, 0x00
    sbc  r25, r18

    ; Límite MIN = 0x000C (12 ovf)
    ldi  r19, 0x00             ; Hmin
    ldi  r18, 0x0C             ; Lmin
    cp   r25, r19              ; compara H
    brlo set_min_dec           ; H < Hmin -> saturar
    brne dec_ok                ; H > Hmin -> OK
    cp   r24, r18              ; H == Hmin -> compara L
    brsh dec_ok                ; L ? Lmin -> OK
set_min_dec:
    mov  r25, r19              ; saturar a MIN
    mov  r24, r18
dec_ok:
    mov  r27, r25              ; recarga contador con nuevo tiempo
    mov  r26, r24
    ori  r21, 0x02             ; set flag DEC
    rjmp dec_cont

dec_suelto:
    andi r21, 0xFD             ; clear flag DEC al soltar

    ; Decremento del contador y fin de espera
dec_cont:
    sbiw r26, 1                ; contador-- (r27:r26)
    brne espera_loop           ; si !=0, seguir esperando
    ret
