#ifndef F_CPU
#define F_CPU 16000000UL
#endif
#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>
 
/* Mapeo de pines */
/* Movimiento (PORTD) */
#define IN1_MASK   (1u<<PD2)   // D2
#define IN2_MASK   (1u<<PD3)   // D3
#define IN3_MASK   (1u<<PD4)   // D4
#define IN4_MASK   (1u<<PD7)   // D7
 
#define ENA_MASK   (1u<<PD5)   // D5  -> OC0B (PWM)
#define ENB_MASK   (1u<<PD6)   // D6  -> OC0A (PWM)
 
/* Patada (PORTB) */
#define K1_MASK    (1u<<PB0)   // D8
#define K2_MASK    (1u<<PB1)   // D9
#define K3_MASK    (1u<<PB4)   // D12
#define K4_MASK    (1u<<PB5)   // D13

//  UART0 (HC-05) 
static void uart_init_9600(void) {
    // 9600 bps @ 16MHz -> UBRR = 103
    UBRR0H = 0;
    UBRR0L = 103;
    UCSR0A = 0x00;
    UCSR0B = (1<<RXEN0) | (1<<TXEN0);
    UCSR0C = (1<<UCSZ01) | (1<<UCSZ00); // 8N1
}
static void uart_putc(char c){
    while(!(UCSR0A & (1<<UDRE0)));
    UDR0 = c;
}
static void uart_puts(const char *s){
    while(*s){ uart_putc(*s++); }
}
static uint8_t uart_rx_available(void){
    return (UCSR0A & (1<<RXC0));
}
static char uart_getc(void){
    while(!uart_rx_available());
    return UDR0;
}
static volatile uint8_t SPEED = 200; // 0..255
 
static void pwm0_init(void){
    // Fast PWM, non-inverting en OC0A (PD6) y OC0B (PD5), prescaler = 64
    // f_pwm ≈ 16MHz / (64*256) ≈ 976 Hz
    TCCR0A = (1<<COM0A1) | (1<<COM0B1) | (1<<WGM01) | (1<<WGM00);
    TCCR0B = (1<<CS01) | (1<<CS00);
    OCR0A = 0;  // ENB
    OCR0B = 0;  // ENA
}
static inline void set_speed(uint8_t duty){
    SPEED = duty;
    OCR0A = duty; // ENB (PD6)
    OCR0B = duty; // ENA (PD5)

static inline void in_all_low(void){
    PORTD &= ~(IN1_MASK | IN2_MASK | IN3_MASK | IN4_MASK);
}
static inline void kick_all_low(void){
    PORTB &= ~(K1_MASK | K2_MASK | K3_MASK | K4_MASK);
}

// Movimiento 
void motores_stop(void){
    set_speed(0);
    in_all_low();
}
 
void motores_forward(void){
    set_speed(SPEED);
    // IN1=H, IN2=L  |  IN3=H, IN4=L
    PORTD = (PORTD | IN1_MASK | IN3_MASK) & ~(IN2_MASK | IN4_MASK);
}

void motores_back(void){
    set_speed(SPEED);
    // IN1=L, IN2=H  |  IN3=L, IN4=H
    PORTD = (PORTD | IN2_MASK | IN4_MASK) & ~(IN1_MASK | IN3_MASK);
}
 
void motores_left(void){
    set_speed(SPEED);
    // IN1=L, IN2=H  |  IN3=H, IN4=L
    PORTD = (PORTD | IN2_MASK | IN3_MASK) & ~(IN1_MASK | IN4_MASK);
}
void motores_right(void){
    set_speed(SPEED);
    // IN1=H, IN2=L  |  IN3=L, IN4=H
    PORTD = (PORTD | IN1_MASK | IN4_MASK) & ~(IN2_MASK | IN3_MASK);
}

void kick_fire(void){
    // Activa ambos motores de patada en un sentido
    PORTB = (PORTB | K1_MASK | K3_MASK) & ~(K2_MASK | K4_MASK);
    _delay_ms(400);
    kick_all_low();
}

// Inicialización de IO
static void io_init(void){
    DDRD |= (ENA_MASK | ENB_MASK | IN1_MASK | IN2_MASK | IN3_MASK | IN4_MASK);
    DDRB |= (K1_MASK | K2_MASK | K3_MASK | K4_MASK);
 
    PORTD &= ~(ENA_MASK | ENB_MASK | IN1_MASK | IN2_MASK | IN3_MASK | IN4_MASK);
    PORTB &= ~(K1_MASK | K2_MASK | K3_MASK | K4_MASK);
}

int main(void){
    io_init();
    pwm0_init();
    uart_init_9600();
 
    motores_stop();
    uart_puts("Robot MiniFutbol listo (F,B,L,R,S,K).\r\n");
 
    for(;;){
        if(uart_rx_available()){
            char c = uart_getc();
            uart_puts("CMD: "); uart_putc(c); uart_puts("\r\n");
 
            switch(c){
                case 'F': motores_forward(); break;
                case 'B': motores_back();    break;
                case 'L': motores_left();    break;
                case 'R': motores_right();   break;
                case 'S': motores_stop();    break;
                case 'K': kick_fire();       break;
                default: /* nada */          break;
            }
        }
        _delay_ms(10);
    }
}

