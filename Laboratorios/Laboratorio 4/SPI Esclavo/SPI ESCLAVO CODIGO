#define F_CPU 16000000UL

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <stdint.h>
#include "SPI.h"

// Definiciones
#define CMD_PLAY_SONG_BIT   0x01

#define SERVO_PIN           PB1
#define BUZZER_PIN          PB0
#define SERVO_DDR           DDRB
#define BUZZER_DDR          DDRB
#define BUZZER_PORT         PORTB

#define LED_TESTIGO         PD7
#define LED_DDR             DDRD
#define LED_PORT            PORTD

#define SERVO_MIN_PULSE     1000
#define SERVO_MAX_PULSE     4800
#define SERVO_STEP_PULSE    600
#define SERVO_DEADBAND      8

// Variables Globales
volatile uint8_t received_data[2];
volatile uint8_t byte_index = 0;
volatile uint8_t data_ready = 0;

static uint16_t servo_pulse_actual = 3000;
static uint16_t servo_pulse_target = 3000;

static uint8_t last_cmd = 0;

// Estado de canción
volatile uint8_t song_playing = 0;
static uint8_t song_index = 0;
static uint16_t song_timer = 0;

enum Note {
	REST = 0,
	C4, D4, E4, F4, G4, A4, B4,
	C5, D5, E5, F5, G5, A5, B5,
	C6, D6, E6
};

static const uint16_t ICR_TAB[] = {
	0, 7644, 6811, 6067, 5727, 5102, 4546, 4050,
	3822, 3405, 3034, 2863, 2551, 2273, 2025,
	1910, 1702, 1516
};

const enum Note melodia[] = { F5, A5, B5, REST, B5, C6, REST, G5 };
const uint16_t duraciones[] = { 200, 200, 400, 100, 300, 300, 100, 400 };
const uint8_t notas = sizeof(melodia) / sizeof(melodia[0]);

// Prototipos
void spi_slave_init(void);
void servo_init(void);
void servo_set_from_byte(uint8_t val);
void servo_update(void);
void buzzer_init(void);
void buzzer_off(void);
void song_update(void);
void delay_ms_var(uint16_t ms);
void delay_us_var(uint16_t us);

// MAIN
int main(void)
{
	servo_init();
	buzzer_init();
	spi_slave_init();

	LED_DDR |= (1 << LED_TESTIGO);
	LED_PORT &= ~(1 << LED_TESTIGO);

	sei();

	while (1)
	{
		// Recepción por SPI
		if (data_ready)
		{
			data_ready = 0;
			uint8_t val = received_data[0];
			uint8_t cmd = received_data[1];

			LED_PORT |= (1 << LED_TESTIGO);

			servo_set_from_byte(val);

			if ((cmd & CMD_PLAY_SONG_BIT) && !(last_cmd & CMD_PLAY_SONG_BIT))
			{
				song_playing = 1;
				song_index = 0;
				song_timer = duraciones[0];
			}
			last_cmd = cmd;

			LED_PORT &= ~(1 << LED_TESTIGO);
		}

		// Canción no bloqueante
		song_update();

		// Servo fluido
		servo_update();
		_delay_ms(10);
	}
}

// SPI ISR
ISR(SPI_STC_vect)
{
	received_data[byte_index] = SPDR;
	byte_index++;

	if (byte_index >= 2)
	{
		byte_index = 0;
		data_ready = 1;
	}
}

// Servo
void servo_init(void)
{
	SERVO_DDR |= (1 << SERVO_PIN);
	TCCR1A = (1 << COM1A1) | (1 << WGM11);
	TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11); // prescaler 8
	ICR1 = 39999;
	OCR1A = servo_pulse_actual;
}

void servo_set_from_byte(uint8_t val)
{
	uint16_t target = SERVO_MIN_PULSE +
	((uint32_t)(SERVO_MAX_PULSE - SERVO_MIN_PULSE) * val) / 255;

	if (target < SERVO_MIN_PULSE) target = SERVO_MIN_PULSE;
	if (target > SERVO_MAX_PULSE) target = SERVO_MAX_PULSE;

	if (target > servo_pulse_target + SERVO_DEADBAND ||
	target + SERVO_DEADBAND < servo_pulse_target)
	{
		servo_pulse_target = target;
	}
}

void servo_update(void)
{
	if (servo_pulse_actual < servo_pulse_target)
	{
		uint16_t diff = servo_pulse_target - servo_pulse_actual;
		servo_pulse_actual += (diff < SERVO_STEP_PULSE) ? diff : SERVO_STEP_PULSE;
	}
	else if (servo_pulse_actual > servo_pulse_target)
	{
		uint16_t diff = servo_pulse_actual - servo_pulse_target;
		servo_pulse_actual -= (diff < SERVO_STEP_PULSE) ? diff : SERVO_STEP_PULSE;
	}
	OCR1A = servo_pulse_actual;
}

// Buzzer y canción no bloqueante
void buzzer_init(void)
{
	BUZZER_DDR |= (1 << BUZZER_PIN);
	buzzer_off();
}

void buzzer_off(void)
{
	BUZZER_PORT &= ~(1 << BUZZER_PIN);
}

void delay_ms_var(uint16_t ms) { while (ms--) _delay_ms(1); }
void delay_us_var(uint16_t us) { while (us--) _delay_us(1); }

// Esta función se llama en loop
void song_update(void)
{
	if (!song_playing) return;

	if (song_timer == 0)
	{
		// Avanzar a la siguiente nota
		song_index++;
		if (song_index >= notas)
		{
			song_playing = 0;
			buzzer_off();
			return;
		}
		song_timer = duraciones[song_index];
	}

	enum Note nota = melodia[song_index];

	if (nota == REST)
	{
		buzzer_off();
	}
	else
	{
		static uint8_t toggle = 0;
		toggle = !toggle;
		if (toggle)
		BUZZER_PORT |= (1 << BUZZER_PIN);
		else
		BUZZER_PORT &= ~(1 << BUZZER_PIN);
	}

	song_timer--;
}

