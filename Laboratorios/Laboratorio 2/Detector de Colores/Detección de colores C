#ifndef F_CPU
#define F_CPU 16000000UL
#endif

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdint.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>

// HARDWARE
#define PIN_WS_BIT   PD4          // WS2812 DIN en D4
#define PIN_SERVO    PB1          // OC1A D9
#define PIN_R        PD3          // OC2B D3
#define PIN_G        PD5          // OC0B D5
#define PIN_B        PD6          // OC0A D6
#define LDR_CH       0            // ADC0 / A0

#define WS_COUNT     64

// SERVO
#define SERVO_MIN_US 500
#define SERVO_MAX_US 2400

// MUESTREO
#define SAMPLES_PER_COLOR  20
#define SAMPLE_DELAY_MS     2
#define SAMPLES_AMBIENT    10
#define MIN_SUM_ADC        30u

// HUE / SAT
#define SAT_MIN          28u
#define TOL_H_PRIM_DEG   28u
#define TOL_H_SEC_DEG    36u

// LED discreto
#define RGB_COMMON_ANODE 0
static inline uint8_t lvl(uint8_t x){ return RGB_COMMON_ANODE ? (255-x) : x; }
static uint8_t levR=255, levG=255, levB=255;
static uint8_t RGB_LEVEL = 255;

#define USE_DEFAULT_PROFILE 1
static const uint16_t DEFAULT_WB[3] = {337, 237, 422};
static const uint8_t  DEFAULT_LEV_R = 179;
static const uint8_t  DEFAULT_LEV_G = 255;
static const uint8_t  DEFAULT_LEV_B = 143;
static const uint8_t  DEFAULT_PRIM_CHR[3][3] = {
  {66,128, 60},   // ROJO
  {57, 86,110},   // VERDE
  {101,75, 77}    // AZUL
};

enum { C_ROJO=0, C_VERDE, C_AZUL, C_AMARILLO, C_NARANJA, C_VIOLETA, C_CELESTE, C_ROSADO, C_COUNT };
static const char* CNAME[C_COUNT] = { "ROJO","VERDE","AZUL","AMARILLO","NARANJA","VIOLETA","CELESTE","ROSADO" };
static const uint16_t DEFAULT_CENTER_HUE[C_COUNT] = {115, 208, 356, 161, 138, 55, 282, 85};

// Estado de calibraciones
enum { IDX_R=0, IDX_G=1, IDX_B=2 };
static uint8_t  prim_ok[3]   = {0,0,0};
static uint8_t  prim_chr[3][3];
static uint16_t prim_hue[3];
static uint16_t center_hue[C_COUNT];
static uint8_t  center_en[C_COUNT];

static uint16_t wb_ref[3]={0,0,0};
static uint8_t  wb_ok=0;

// Servo y WS
static int      servoAngle = 90;
static uint8_t  servoAuto  = 1;
static int      lastIdx    = -1;
static uint8_t  stable     = 0;
#define STABLE_N 2

// ================= PROTOTIPOS =================
// UART
static void   uart_init(void);
static uint8_t uart_available(void);
static uint8_t uart_getc_nonblock(char *c);
static void   uart_putc(char c);
static void   uart_puts(const char*s);
static void   uart_printf(const char *fmt, ...);

// ADC
static void     adc_init(void);
static uint16_t adc_read_once(uint8_t ch);

// PWM RGB discreto
static void rgb_pwm_init(void);
static void rgb_set_raw(uint8_t r,uint8_t g,uint8_t b);
static void rgb_off(void);
static void rgb_set(uint8_t r,uint8_t g,uint8_t b);

// SERVO (Timer1)
static void     servo_init(void);
static uint16_t us_to_ocr(uint16_t us);
static void     servo_write_us(uint16_t us);
static void     servo_set_deg(int a);

// WS2812 (bit-bang)
static void ws_show_GRB(uint8_t g,uint8_t r,uint8_t b);
static void ws_off(void);
static void ws_fill(uint8_t R,uint8_t G,uint8_t B);

// Sensor/color helpers
static inline uint16_t sub_sat(uint16_t a, uint16_t b);
static uint16_t ambient_avg(void);
static uint16_t measure_color(uint8_t r,uint8_t g,uint8_t b);
static void     measure_triplet_u16(uint16_t m[3]);
static uint8_t  chroma8_from_u16(const uint16_t in[3], uint8_t out[3]);
static uint8_t  hue_sat_from_rgb8(uint8_t r, uint8_t g, uint8_t b, uint16_t* hue_deg, uint8_t* sat);
static uint16_t circ_mid(uint16_t a,uint16_t b);
static uint16_t circ_dist(uint16_t a,uint16_t b);

// White balance + LED balance
static void apply_white_balance(const uint16_t in[3], uint16_t out[3]);
static void wb_calibrate(void);
static void led_balance_calibrate(void);
static uint8_t gain_from_pair(uint16_t x,uint16_t tgt);

// Centros / primarios / clasificación
static void recompute_centers(void);
static void calibrate_primary(uint8_t idx);
static int  classify_hue(const uint16_t raw_meas0[3], uint16_t* h_out, uint8_t* s_out);

// Servo + Matriz
static void matrix_for_color(int cid);
static void servo_on_color_idx(int cid);

// UI
static void print_menu(void);
static void show_rgb_refs(void);
static void show_centers(void);
static void debug_distances_ui(const uint16_t raw0[3]);

// Perfil + main
static void load_defaults(void);

// UART
static void uart_init(void){
    UCSR0A = (1<<U2X0);
    uint16_t ubrr = (F_CPU/8/9600UL) - 1;
    UBRR0H = ubrr >> 8; UBRR0L = ubrr & 0xFF;
    UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
}
static inline uint8_t uart_available(void){ return (UCSR0A & (1<<RXC0)); }
static inline uint8_t uart_getc_nonblock(char *c){ if(!uart_available()) return 0; *c=UDR0; return 1; }
static void uart_putc(char c){ while(!(UCSR0A&(1<<UDRE0))); UDR0=c; }
static void uart_puts(const char*s){ while(*s) uart_putc(*s++); }
static void uart_printf(const char *fmt, ...){
    char buf[160]; va_list ap; va_start(ap, fmt);
    vsnprintf(buf, sizeof buf, fmt, ap); va_end(ap);
    uart_puts(buf);
}

// ADC
static void adc_init(void){
    ADMUX  = (1<<REFS0) | (LDR_CH & 0x0F);
    ADCSRA = (1<<ADEN)  | (1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
}
static uint16_t adc_read_once(uint8_t ch){
    ADMUX = (ADMUX & 0xF0) | (ch & 0x0F);
    ADCSRA |= (1<<ADSC); while (ADCSRA & (1<<ADSC));
    uint8_t lo=ADCL, hi=ADCH; return ((uint16_t)hi<<8)|lo;
}


// PWM RGB
static void rgb_pwm_init(void){
    DDRD |= (1<<PIN_R)|(1<<PIN_G)|(1<<PIN_B);
    TCCR0A = (1<<COM0A1)|(1<<COM0B1)|(1<<WGM01)|(1<<WGM00);
    TCCR0B = (1<<CS01)|(1<<CS00);
    TCCR2A = (1<<COM2B1)|(1<<WGM21)|(1<<WGM20);
    TCCR2B = (1<<CS22);
    OCR0A=0; OCR0B=0; OCR2B=0;
}
static inline void rgb_set_raw(uint8_t r,uint8_t g,uint8_t b){
    OCR2B = RGB_COMMON_ANODE? (255-r) : r;
    OCR0B = RGB_COMMON_ANODE? (255-g) : g;
    OCR0A = RGB_COMMON_ANODE? (255-b) : b;
}
static inline void rgb_off(void){ rgb_set_raw(0,0,0); }
static inline void rgb_set(uint8_t r,uint8_t g,uint8_t b){
    rgb_set_raw(r?levR:0, g?levG:0, b?levB:0);
}

// SERVO (Timer1)
static void servo_init(void){
    DDRB  |= (1<<PIN_SERVO);
    TCCR1A = (1<<COM1A1)|(1<<WGM11);
    TCCR1B = (1<<WGM13)|(1<<WGM12)|(1<<CS11); // presc=8, TOP=ICR1
    ICR1   = 39999;                            // 20 ms -> 40000 ticks @0.5us
}
static inline uint16_t us_to_ocr(uint16_t us){ if(us<400)us=400; if(us>2600)us=2600; return (uint16_t)(us*2); }
static void servo_write_us(uint16_t us){ OCR1A = us_to_ocr(us); }
static void servo_set_deg(int a){
    if(a<0)a=0; if(a>180)a=180;
    if(a!=servoAngle){ servoAngle=a;
        uint32_t span = (uint32_t)(SERVO_MAX_US - SERVO_MIN_US);
        uint16_t us = SERVO_MIN_US + (uint16_t)(span * (uint32_t)a / 180UL);
        servo_write_us(us);
    }
}

// WS2812 — bit-bang @16 MHz
static inline void ws_pin_high(void){ PORTD |=  (1<<PIN_WS_BIT); }
static inline void ws_pin_low (void){ PORTD &= ~(1<<PIN_WS_BIT); }

static inline void ws_send_bit_1(void){
    ws_pin_high();  __builtin_avr_delay_cycles(10);  // ~0.625us + sbi
    ws_pin_low();   __builtin_avr_delay_cycles(8);   // ~0.5us + cbi
}
static inline void ws_send_bit_0(void){
    ws_pin_high();  __builtin_avr_delay_cycles(4);   // ~0.25us + sbi
    ws_pin_low();   __builtin_avr_delay_cycles(12);  // ~0.75us + cbi
}
static inline void ws_send_byte(uint8_t b){ // MSB primero, WS = GRB
    for(uint8_t i=0;i<8;i++){
        if(b & 0x80) ws_send_bit_1(); else ws_send_bit_0();
        b <<= 1;
    }
}
static void ws_show_GRB(uint8_t g,uint8_t r,uint8_t b){
    cli();
    for(uint16_t i=0;i<WS_COUNT;i++){
        ws_send_byte(g); ws_send_byte(r); ws_send_byte(b);
    }
    sei();
    _delay_us(60);
}
static inline void ws_off(void){ ws_show_GRB(0,0,0); }
static inline void ws_fill(uint8_t R,uint8_t G,uint8_t B){ ws_show_GRB(G,R,B); }

static inline uint16_t sub_sat(uint16_t a, uint16_t b){ return (a>b)?(uint16_t)(a-b):0; }

static uint16_t ambient_avg(void){
    rgb_off(); _delay_ms(3);
    uint32_t acc=0;
    for(uint8_t i=0;i<SAMPLES_AMBIENT;i++){ acc+=adc_read_once(LDR_CH); _delay_ms(SAMPLE_DELAY_MS); }
    return (uint16_t)(acc/SAMPLES_AMBIENT);
}
static uint16_t measure_color(uint8_t r,uint8_t g,uint8_t b){
    rgb_set(r?RGB_LEVEL:0, g?RGB_LEVEL:0, b?RGB_LEVEL:0);
    _delay_ms(5);
    uint32_t acc=0;
    for(uint8_t i=0;i<SAMPLES_PER_COLOR;i++){ acc+=adc_read_once(LDR_CH); _delay_ms(SAMPLE_DELAY_MS); }
    rgb_off(); return (uint16_t)(acc/SAMPLES_PER_COLOR);
}
static void measure_triplet_u16(uint16_t m[3]){
    uint16_t amb = ambient_avg();
    uint16_t R = measure_color(1,0,0);
    uint16_t G = measure_color(0,1,0);
    uint16_t B = measure_color(0,0,1);
    m[0]=sub_sat(R,amb); m[1]=sub_sat(G,amb); m[2]=sub_sat(B,amb);
}

static uint8_t chroma8_from_u16(const uint16_t in[3], uint8_t out[3]){
    uint32_t s=(uint32_t)in[0]+in[1]+in[2];
    if(s < MIN_SUM_ADC){ out[0]=out[1]=out[2]=0; return 0; }
    out[0]=(uint8_t)((in[0]*255UL)/s);
    out[1]=(uint8_t)((in[1]*255UL)/s);
    out[2]=(uint8_t)((in[2]*255UL)/s);
    return 1;
}
static uint8_t hue_sat_from_rgb8(uint8_t r, uint8_t g, uint8_t b, uint16_t* hue_deg, uint8_t* sat){
    uint8_t max=r; if(g>max) max=g; if(b>max) max=b;
    uint8_t min=r; if(g<min) min=g; if(b<min) min=b;
    uint8_t delta=max-min;
    if(max==0){ *sat=0; *hue_deg=0; return 0; }
    *sat=(uint8_t)(((uint16_t)delta*255U)/max);
    if(delta==0){ *hue_deg=0; return 0; }
    int32_t h;
    if(max==r)      h =   0 + 60*(int32_t)((int16_t)g-(int16_t)b)/delta;
    else if(max==g) h = 120 + 60*(int32_t)((int16_t)b-(int16_t)r)/delta;
    else            h = 240 + 60*(int32_t)((int16_t)r-(int16_t)g)/delta;
    while(h<0) h+=360; while(h>=360) h-=360;
    *hue_deg=(uint16_t)h; return 1;
}
static inline uint16_t circ_mid(uint16_t a,uint16_t b){
    int16_t d=(int16_t)b-(int16_t)a; while(d<-180)d+=360; while(d>180)d-=360;
    int16_t m=(int16_t)a + d/2; while(m<0)m+=360; while(m>=360)m-=360; return (uint16_t)m;
}
static inline uint16_t circ_dist(uint16_t a,uint16_t b){
    int16_t d=(int16_t)a-(int16_t)b; while(d<-180)d+=360; while(d>180)d-=360; if(d<0)d=-d; return (uint16_t)d;
}

// balance blancos y balance led

static void apply_white_balance(const uint16_t in[3], uint16_t out[3]){
    if(!wb_ok){ out[0]=in[0]; out[1]=in[1]; out[2]=in[2]; return; }
    uint32_t s=(uint32_t)wb_ref[0]+wb_ref[1]+wb_ref[2];
    if(s==0){ out[0]=in[0]; out[1]=in[1]; out[2]=in[2]; return; }
    uint32_t tgt=s/3;
    for(uint8_t i=0;i<3;i++){ uint32_t den=wb_ref[i]?wb_ref[i]:1; uint32_t v=(uint32_t)in[i]*tgt/den; if(v>65535U)v=65535U; out[i]=(uint16_t)v; }
}
static void wb_calibrate(void){
    uint16_t raw[3]; measure_triplet_u16(raw);
    wb_ref[0]=raw[0]; wb_ref[1]=raw[1]; wb_ref[2]=raw[2]; wb_ok=1;
    uart_printf("WB blanco RAW: R=%u G=%u B=%u\r\n> ", wb_ref[0],wb_ref[1],wb_ref[2]);
}

static uint8_t gain_from_pair(uint16_t x,uint16_t tgt){ if(x==0) return 255; uint32_t v=(uint32_t)RGB_LEVEL*tgt/x; if(v>255)v=255; return (uint8_t)v; }
static void led_balance_calibrate(void){
    uint16_t amb = ambient_avg();
    rgb_set_raw(255,0,0); _delay_ms(5); uint32_t aR=0; for(uint8_t i=0;i<SAMPLES_PER_COLOR;i++){ aR+=adc_read_once(LDR_CH); _delay_ms(SAMPLE_DELAY_MS); } rgb_off();
    rgb_set_raw(0,255,0); _delay_ms(5); uint32_t aG=0; for(uint8_t i=0;i<SAMPLES_PER_COLOR;i++){ aG+=adc_read_once(LDR_CH); _delay_ms(SAMPLE_DELAY_MS); } rgb_off();
    rgb_set_raw(0,0,255); _delay_ms(5); uint32_t aB=0; for(uint8_t i=0;i<SAMPLES_PER_COLOR;i++){ aB+=adc_read_once(LDR_CH); _delay_ms(SAMPLE_DELAY_MS); } rgb_off();
    uint16_t r0=sub_sat((uint16_t)(aR/SAMPLES_PER_COLOR),amb);
    uint16_t g0=sub_sat((uint16_t)(aG/SAMPLES_PER_COLOR),amb);
    uint16_t b0=sub_sat((uint16_t)(aB/SAMPLES_PER_COLOR),amb);
    uint32_t s=(uint32_t)r0+g0+b0; if(s<3){ uart_puts("LED balance: poca luz\r\n> "); return; }
    uint16_t tgt=(uint16_t)(s/3);
    levR=gain_from_pair(r0,tgt); levG=gain_from_pair(g0,tgt); levB=gain_from_pair(b0,tgt);
    uart_printf("LED balance: rawW R=%u G=%u B=%u -> levR=%u levG=%u levB=%u\r\n> ",
                r0,g0,b0, levR,levG,levB);
}

static void recompute_centers(void){
    for(uint8_t i=0;i<3;i++){
        if(prim_ok[i]){
            uint16_t h; uint8_t s;
            hue_sat_from_rgb8(prim_chr[i][0],prim_chr[i][1],prim_chr[i][2], &h,&s);
            prim_hue[i]=h; center_hue[i]=h; center_en[i]=1;
        }else center_en[i]=0;
    }
    if(prim_ok[0]&&prim_ok[1]&&prim_ok[2]){
        uint16_t Hy = circ_mid(prim_hue[IDX_R], prim_hue[IDX_G]);
        uint16_t Hc = circ_mid(prim_hue[IDX_G], prim_hue[IDX_B]);
        uint16_t Hv = circ_mid(prim_hue[IDX_B], prim_hue[IDX_R]);
        center_hue[C_AMARILLO]=Hy; center_en[C_AMARILLO]=1;
        center_hue[C_CELESTE ]=Hc; center_en[C_CELESTE ]=1;
        center_hue[C_VIOLETA ]=Hv; center_en[C_VIOLETA ]=1;
        center_hue[C_NARANJA ]=circ_mid(prim_hue[IDX_R], Hy); center_en[C_NARANJA ]=1;
        center_hue[C_ROSADO  ]=circ_mid(prim_hue[IDX_R], Hv); center_en[C_ROSADO  ]=1;
    }else{
        center_en[C_AMARILLO]=center_en[C_CELESTE]=center_en[C_VIOLETA]=0;
        center_en[C_NARANJA]=center_en[C_ROSADO]=0;
    }
}
static void calibrate_primary(uint8_t idx){
    uint16_t raw0[3]; measure_triplet_u16(raw0);
    uint16_t raw[3];  apply_white_balance(raw0, raw);
    uint8_t  chr[3];  chroma8_from_u16(raw, chr);
    prim_chr[idx][0]=chr[0]; prim_chr[idx][1]=chr[1]; prim_chr[idx][2]=chr[2]; prim_ok[idx]=1;
    uint16_t h; uint8_t s; hue_sat_from_rgb8(chr[0],chr[1],chr[2], &h,&s); prim_hue[idx]=h;
    recompute_centers();
    const char* nm=(idx==0?"ROJO":(idx==1?"VERDE":"AZUL"));
    uart_printf("Ref %s RAW R:%u G:%u B:%u | NORM r:%u g:%u b:%u | H=%u S=%u\r\n> ",
                nm, raw[0],raw[1],raw[2], chr[0],chr[1],chr[2], h, s);
}
static int classify_hue(const uint16_t raw_meas0[3], uint16_t* h_out, uint8_t* s_out){
    uint16_t raw[3]; apply_white_balance(raw_meas0, raw);
    uint8_t chr[3]; if(!chroma8_from_u16(raw, chr)) return -2;
    uint16_t h; uint8_t s; if(!hue_sat_from_rgb8(chr[0],chr[1],chr[2], &h,&s)) return -1;
    if(s<SAT_MIN) return -1;
    if(h_out)*h_out=h; if(s_out)*s_out=s;
    uint16_t best_d=1000; int8_t best_i=-3;
    for(uint8_t i=0;i<C_COUNT;i++){
        if(!center_en[i]) continue;
        uint16_t d=circ_dist(h,center_hue[i]);
        uint16_t tol=(i<=C_AZUL)?TOL_H_PRIM_DEG:TOL_H_SEC_DEG;
        if(d<best_d && d<=tol){ best_d=d; best_i=i; }
    }
    return best_i;
}

static void matrix_for_color(int cid){
    switch(cid){
        case C_VIOLETA:  ws_fill(180,  0,220); break;
        case C_ROSADO:   ws_fill(255, 60,120); break;
        case C_ROJO:     ws_fill(255,  0,  0); break;
        case C_AMARILLO: ws_fill(255,180,  0); break;
        default:         ws_off();             break;
    }
}
static void servo_on_color_idx(int cid){
    int target=-1;
    if      (cid==C_VIOLETA)  target=  0;
    else if (cid==C_ROSADO)   target= 60;
    else if (cid==C_ROJO)     target=120;
    else if (cid==C_AMARILLO) target=180;
    else { ws_off(); return; }
    if(target!=servoAngle){ servo_set_deg(target); matrix_for_color(cid); }
}

//UI (menú) y utilidades de debug

static void print_menu(void){
    uart_puts("\r\n===== MENU =====\r\n");
    uart_puts(" 1/2/3) Calibrar ROJO/VERDE/AZUL\r\n");
    uart_puts(" L) LED balance  |  w) White balance\r\n");
    uart_puts(" m) Medir+clasif |  d) Debug distancias\r\n");
    uart_puts(" h) Mostrar centros  |  s) Mostrar primarios\r\n");
    uart_puts(" z) Cargar perfil por defecto\r\n");
    uart_puts(" j) Test RGB (R,G,B)\r\n");
    uart_puts(" u) Servo AUTO on/off | A/B/C/D/E = 0/45/90/135/180 | p) angulo\r\n");
    uart_puts(" x) Borrar calibraciones\r\n> ");
}
static void show_rgb_refs(void){
    uart_puts("\r\n--- PRIMARIOS (r,g,b; H,S) ---\r\n");
    for(uint8_t i=0;i<3;i++){
        const char* nm=(i==0?"ROJO":(i==1?"VERDE":"AZUL"));
        if(prim_ok[i]){
            uint16_t h; uint8_t s;
            hue_sat_from_rgb8(prim_chr[i][0],prim_chr[i][1],prim_chr[i][2], &h,&s);
            uart_printf("%-5s: r=%3u g=%3u b=%3u | H=%3u S=%3u\r\n",
                        nm, prim_chr[i][0],prim_chr[i][1],prim_chr[i][2], h, s);
        }else uart_printf("%-5s: (sin calibrar)\r\n", nm);
    }
    uart_printf("LEV: R=%u G=%u B=%u | WB:%s | Servo:%s @%d\r\n> ",
                levR,levG,levB, wb_ok?"OK":"NO", servoAuto?"AUTO":"MAN", servoAngle);
}
static void show_centers(void){
    uart_puts("\r\n--- CENTROS (H en grados) ---\r\n");
    for(uint8_t i=0;i<C_COUNT;i++){
        uart_puts(CNAME[i]); uart_puts(": ");
        if(center_en[i]) uart_printf("H=%u\r\n", center_hue[i]); else uart_puts("(deshabilitado)\r\n");
    }
    uart_puts("> ");
}
static void debug_distances_ui(const uint16_t raw0[3]){
    uint16_t raw[3]; apply_white_balance(raw0,raw);
    uint8_t chr[3]; if(!chroma8_from_u16(raw,chr)){ uart_puts("POCA_LUZ\r\n> "); return; }
    uint16_t h; uint8_t s; hue_sat_from_rgb8(chr[0],chr[1],chr[2], &h,&s);
    uart_printf("NORM=(%u,%u,%u) H=%u S=%u\r\n", chr[0],chr[1],chr[2], h, s);
    for(uint8_t i=0;i<C_COUNT;i++){
        if(!center_en[i]) continue;
        uint16_t d=circ_dist(h, center_hue[i]);
        uint16_t tol=(i<=C_AZUL)?TOL_H_PRIM_DEG:TOL_H_SEC_DEG;
        uart_printf(" %-8s: Hc=%3u  d=%3u  %s\r\n", CNAME[i], center_hue[i], d, (d<=tol?"<--":""));
    }
    uart_puts("> ");
}

static void load_defaults(void){
    levR=DEFAULT_LEV_R; levG=DEFAULT_LEV_G; levB=DEFAULT_LEV_B;
    wb_ref[0]=DEFAULT_WB[0]; wb_ref[1]=DEFAULT_WB[1]; wb_ref[2]=DEFAULT_WB[2]; wb_ok=1;
    for(uint8_t i=0;i<3;i++){ prim_chr[i][0]=DEFAULT_PRIM_CHR[i][0]; prim_chr[i][1]=DEFAULT_PRIM_CHR[i][1]; prim_chr[i][2]=DEFAULT_PRIM_CHR[i][2]; prim_ok[i]=1; }
    for(uint8_t i=0;i<C_COUNT;i++){ center_hue[i]=DEFAULT_CENTER_HUE[i]; center_en[i]=1; }
    uart_puts("[Perfil por defecto CARGADO]\r\n> ");
}

int main(void){
    uart_init(); adc_init(); rgb_pwm_init(); servo_init();
    DDRD |= (1<<PIN_WS_BIT); ws_off();
    sei();

    // arranque: rosado (60°) para verificar servo y WS
    servo_on_color_idx(C_ROSADO);
    #if USE_DEFAULT_PROFILE
      load_defaults();
    #endif

    uart_puts("\r\n=== LDR+RGB HUE + SERVO + WS (AVR-C) ===\r\n");
    print_menu();

    for(;;){
        char ch=0;
        if(!uart_getc_nonblock(&ch)){ _delay_ms(1); continue; }
        if(ch=='\r'||ch=='\n'||ch==' ') continue;

        if(ch=='j'||ch=='J'){
            uart_puts("\r\nTest RGB: R,G,B\r\n");
            rgb_set_raw(255,0,0); _delay_ms(600);
            rgb_set_raw(0,255,0); _delay_ms(600);
            rgb_set_raw(0,0,255); _delay_ms(600);
            rgb_off(); uart_puts("> ");
        }
        else if(ch=='z'||ch=='Z'){ load_defaults(); }
        else if(ch=='L'){ uart_puts("\r\n[LED BAL] Blanco...\r\n"); led_balance_calibrate(); }
        else if(ch=='w'||ch=='W'){ uart_puts("\r\n[WB] Blanco...\r\n"); wb_calibrate(); }

        else if(ch=='u'||ch=='U'){ servoAuto^=1; uart_printf("\r\nServo AUTO: %s (angulo=%d)\r\n> ", servoAuto?"ON":"OFF", servoAngle); }
        else if(ch=='A'){ servo_set_deg(0);   ws_off(); uart_puts("\r\n> "); }
        else if(ch=='B'){ servo_set_deg(45);  ws_off(); uart_puts("\r\n> "); }
        else if(ch=='C'){ servo_set_deg(90);  ws_off(); uart_puts("\r\n> "); }
        else if(ch=='D'){ servo_set_deg(135); ws_off(); uart_puts("\r\n> "); }
        else if(ch=='E'){ servo_set_deg(180); ws_off(); uart_puts("\r\n> "); }

        else if(ch=='1'||ch=='2'||ch=='3'){
            uint8_t idx=(uint8_t)(ch-'1'); const char* nm=(idx==0?"ROJO":(idx==1?"VERDE":"AZUL"));
            uart_printf("\r\n[Calibrando %s] coloca muestra...\r\n", nm); calibrate_primary(idx);
        }
        else if(ch=='m'||ch=='M'){
            uint16_t raw0[3]; measure_triplet_u16(raw0);
            uint16_t h; uint8_t s; int cls=classify_hue(raw0,&h,&s);

            uint16_t raw[3]; apply_white_balance(raw0, raw);
            uint8_t  chr[3]; uint8_t ok=chroma8_from_u16(raw, chr);

            const char* name=(cls>=0)?CNAME[cls] : (cls==-1?"BAJA_SAT":"POCA_LUZ/INDEF");
            if(!ok){ uart_puts("\r\nPOCA_LUZ.\r\n> "); }
            else{
                uart_printf("\r\nRAW  R:%4u G:%4u B:%4u | NORM r:%3u g:%3u b:%3u | H=%3u S=%3u -> %s\r\n",
                            raw[0],raw[1],raw[2], chr[0],chr[1],chr[2], h, s, name);

                if(servoAuto && cls>=0){
                    if(cls==lastIdx){ if(stable<255) stable++; } else { lastIdx=cls; stable=1; }
                    if(stable>=STABLE_N){ servo_on_color_idx(cls); stable=0; }
                } else { stable=0; }
                uart_puts("> ");
            }
        }
        else if(ch=='d'||ch=='D'){ uint16_t r0[3]; measure_triplet_u16(r0); debug_distances_ui(r0); }
        else if(ch=='s'||ch=='S'){ show_rgb_refs(); }
        else if(ch=='h'||ch=='H'){ show_centers(); }
        else if(ch=='p'||ch=='P'){ uart_printf("\r\nServo angulo: %d  (AUTO=%s)\r\n> ", servoAngle, servoAuto?"AUTO":"OFF"); }
        else if(ch=='x'||ch=='X'){
            for(uint8_t i=0;i<3;i++) prim_ok[i]=0;
            for(uint8_t i=0;i<C_COUNT;i++) center_en[i]=0;
            wb_ok=0; ws_off();
            uart_puts("\r\nCalibraciones borradas.\r\n"); print_menu();
        }
        else { uart_puts("\r\nComando invalido.\r\n"); print_menu(); }
    }
}
