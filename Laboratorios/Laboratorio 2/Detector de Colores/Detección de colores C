#ifndef F_CPU
#define F_CPU 16000000UL
#endif

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdint.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>

// HARDWARE
#define PIN_WS_BIT   PD4          // WS2812 DIN en D4
#define PIN_SERVO    PB1          // OC1A D9
#define PIN_R        PD3          // OC2B D3
#define PIN_G        PD5          // OC0B D5
#define PIN_B        PD6          // OC0A D6
#define LDR_CH       0            // ADC0 / A0

#define WS_COUNT     64

// SERVO
#define SERVO_MIN_US 500
#define SERVO_MAX_US 2400

// MUESTREO
#define SAMPLES_PER_COLOR  20
#define SAMPLE_DELAY_MS     2
#define SAMPLES_AMBIENT    10
#define MIN_SUM_ADC        30u

// HUE / SAT
#define SAT_MIN          28u
#define TOL_H_PRIM_DEG   28u
#define TOL_H_SEC_DEG    36u

// LED discreto
#define RGB_COMMON_ANODE 0
static inline uint8_t lvl(uint8_t x){ return RGB_COMMON_ANODE ? (255-x) : x; }
static uint8_t levR=255, levG=255, levB=255;
static uint8_t RGB_LEVEL = 255;

#define USE_DEFAULT_PROFILE 1
static const uint16_t DEFAULT_WB[3] = {337, 237, 422};
static const uint8_t  DEFAULT_LEV_R = 179;
static const uint8_t  DEFAULT_LEV_G = 255;
static const uint8_t  DEFAULT_LEV_B = 143;
static const uint8_t  DEFAULT_PRIM_CHR[3][3] = {
  {66,128, 60},   // ROJO
  {57, 86,110},   // VERDE
  {101,75, 77}    // AZUL
};

enum { C_ROJO=0, C_VERDE, C_AZUL, C_AMARILLO, C_NARANJA, C_VIOLETA, C_CELESTE, C_ROSADO, C_COUNT };
static const char* CNAME[C_COUNT] = { "ROJO","VERDE","AZUL","AMARILLO","NARANJA","VIOLETA","CELESTE","ROSADO" };
static const uint16_t DEFAULT_CENTER_HUE[C_COUNT] = {115, 208, 356, 161, 138, 55, 282, 85};

// Estado de calibraciones
enum { IDX_R=0, IDX_G=1, IDX_B=2 };
static uint8_t  prim_ok[3]   = {0,0,0};
static uint8_t  prim_chr[3][3];
static uint16_t prim_hue[3];
static uint16_t center_hue[C_COUNT];
static uint8_t  center_en[C_COUNT];

static uint16_t wb_ref[3]={0,0,0};
static uint8_t  wb_ok=0;

// Servo y WS
static int      servoAngle = 90;
static uint8_t  servoAuto  = 1;
static int      lastIdx    = -1;
static uint8_t  stable     = 0;
#define STABLE_N 2

// ================= PROTOTIPOS =================
// UART
static void   uart_init(void);
static uint8_t uart_available(void);
static uint8_t uart_getc_nonblock(char *c);
static void   uart_putc(char c);
static void   uart_puts(const char*s);
static void   uart_printf(const char *fmt, ...);

// ADC
static void     adc_init(void);
static uint16_t adc_read_once(uint8_t ch);

// PWM RGB discreto
static void rgb_pwm_init(void);
static void rgb_set_raw(uint8_t r,uint8_t g,uint8_t b);
static void rgb_off(void);
static void rgb_set(uint8_t r,uint8_t g,uint8_t b);

// SERVO (Timer1)
static void     servo_init(void);
static uint16_t us_to_ocr(uint16_t us);
static void     servo_write_us(uint16_t us);
static void     servo_set_deg(int a);

// WS2812 (bit-bang)
static void ws_show_GRB(uint8_t g,uint8_t r,uint8_t b);
static void ws_off(void);
static void ws_fill(uint8_t R,uint8_t G,uint8_t B);

// Sensor/color helpers
static inline uint16_t sub_sat(uint16_t a, uint16_t b);
static uint16_t ambient_avg(void);
static uint16_t measure_color(uint8_t r,uint8_t g,uint8_t b);
static void     measure_triplet_u16(uint16_t m[3]);
static uint8_t  chroma8_from_u16(const uint16_t in[3], uint8_t out[3]);
static uint8_t  hue_sat_from_rgb8(uint8_t r, uint8_t g, uint8_t b, uint16_t* hue_deg, uint8_t* sat);
static uint16_t circ_mid(uint16_t a,uint16_t b);
static uint16_t circ_dist(uint16_t a,uint16_t b);

// White balance + LED balance
static void apply_white_balance(const uint16_t in[3], uint16_t out[3]);
static void wb_calibrate(void);
static void led_balance_calibrate(void);
static uint8_t gain_from_pair(uint16_t x,uint16_t tgt);

// Centros / primarios / clasificación
static void recompute_centers(void);
static void calibrate_primary(uint8_t idx);
static int  classify_hue(const uint16_t raw_meas0[3], uint16_t* h_out, uint8_t* s_out);

// Servo + Matriz
static void matrix_for_color(int cid);
static void servo_on_color_idx(int cid);

// UI
static void print_menu(void);
static void show_rgb_refs(void);
static void show_centers(void);
static void debug_distances_ui(const uint16_t raw0[3]);

// Perfil + main
static void load_defaults(void);

// UART
static void uart_init(void){
    UCSR0A = (1<<U2X0);
    uint16_t ubrr = (F_CPU/8/9600UL) - 1;
    UBRR0H = ubrr >> 8; UBRR0L = ubrr & 0xFF;
    UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
}
static inline uint8_t uart_available(void){ return (UCSR0A & (1<<RXC0)); }
static inline uint8_t uart_getc_nonblock(char *c){ if(!uart_available()) return 0; *c=UDR0; return 1; }
static void uart_putc(char c){ while(!(UCSR0A&(1<<UDRE0))); UDR0=c; }
static void uart_puts(const char*s){ while(*s) uart_putc(*s++); }
static void uart_printf(const char *fmt, ...){
    char buf[160]; va_list ap; va_start(ap, fmt);
    vsnprintf(buf, sizeof buf, fmt, ap); va_end(ap);
    uart_puts(buf);
}

// ADC
static void adc_init(void){
    ADMUX  = (1<<REFS0) | (LDR_CH & 0x0F);
    ADCSRA = (1<<ADEN)  | (1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
}
static uint16_t adc_read_once(uint8_t ch){
    ADMUX = (ADMUX & 0xF0) | (ch & 0x0F);
    ADCSRA |= (1<<ADSC); while (ADCSRA & (1<<ADSC));
    uint8_t lo=ADCL, hi=ADCH; return ((uint16_t)hi<<8)|lo;
}


// PWM RGB
static void rgb_pwm_init(void){
    DDRD |= (1<<PIN_R)|(1<<PIN_G)|(1<<PIN_B);
    TCCR0A = (1<<COM0A1)|(1<<COM0B1)|(1<<WGM01)|(1<<WGM00);
    TCCR0B = (1<<CS01)|(1<<CS00);
    TCCR2A = (1<<COM2B1)|(1<<WGM21)|(1<<WGM20);
    TCCR2B = (1<<CS22);
    OCR0A=0; OCR0B=0; OCR2B=0;
}
static inline void rgb_set_raw(uint8_t r,uint8_t g,uint8_t b){
    OCR2B = RGB_COMMON_ANODE? (255-r) : r;
    OCR0B = RGB_COMMON_ANODE? (255-g) : g;
    OCR0A = RGB_COMMON_ANODE? (255-b) : b;
}
static inline void rgb_off(void){ rgb_set_raw(0,0,0); }
static inline void rgb_set(uint8_t r,uint8_t g,uint8_t b){
    rgb_set_raw(r?levR:0, g?levG:0, b?levB:0);
}

// SERVO (Timer1)
static void servo_init(void){
    DDRB  |= (1<<PIN_SERVO);
    TCCR1A = (1<<COM1A1)|(1<<WGM11);
    TCCR1B = (1<<WGM13)|(1<<WGM12)|(1<<CS11); // presc=8, TOP=ICR1
    ICR1   = 39999;                            // 20 ms -> 40000 ticks @0.5us
}
static inline uint16_t us_to_ocr(uint16_t us){ if(us<400)us=400; if(us>2600)us=2600; return (uint16_t)(us*2); }
static void servo_write_us(uint16_t us){ OCR1A = us_to_ocr(us); }
static void servo_set_deg(int a){
    if(a<0)a=0; if(a>180)a=180;
    if(a!=servoAngle){ servoAngle=a;
        uint32_t span = (uint32_t)(SERVO_MAX_US - SERVO_MIN_US);
        uint16_t us = SERVO_MIN_US + (uint16_t)(span * (uint32_t)a / 180UL);
        servo_write_us(us);
    }
}

// WS2812 — bit-bang @16 MHz
static inline void ws_pin_high(void){ PORTD |=  (1<<PIN_WS_BIT); }
static inline void ws_pin_low (void){ PORTD &= ~(1<<PIN_WS_BIT); }

static inline void ws_send_bit_1(void){
    ws_pin_high();  __builtin_avr_delay_cycles(10);  // ~0.625us + sbi
    ws_pin_low();   __builtin_avr_delay_cycles(8);   // ~0.5us + cbi
}
static inline void ws_send_bit_0(void){
    ws_pin_high();  __builtin_avr_delay_cycles(4);   // ~0.25us + sbi
    ws_pin_low();   __builtin_avr_delay_cycles(12);  // ~0.75us + cbi
}
static inline void ws_send_byte(uint8_t b){ // MSB primero, WS = GRB
    for(uint8_t i=0;i<8;i++){
        if(b & 0x80) ws_send_bit_1(); else ws_send_bit_0();
        b <<= 1;
    }
}
static void ws_show_GRB(uint8_t g,uint8_t r,uint8_t b){
    cli();
    for(uint16_t i=0;i<WS_COUNT;i++){
        ws_send_byte(g); ws_send_byte(r); ws_send_byte(b);
    }
    sei();
    _delay_us(60);
}
static inline void ws_off(void){ ws_show_GRB(0,0,0); }
static inline void ws_fill(uint8_t R,uint8_t G,uint8_t B){ ws_show_GRB(G,R,B); }

static inline uint16_t sub_sat(uint16_t a, uint16_t b){ return (a>b)?(uint16_t)(a-b):0; }

static uint16_t ambient_avg(void){
    rgb_off(); _delay_ms(3);
    uint32_t acc=0;
    for(uint8_t i=0;i<SAMPLES_AMBIENT;i++){ acc+=adc_read_once(LDR_CH); _delay_ms(SAMPLE_DELAY_MS); }
    return (uint16_t)(acc/SAMPLES_AMBIENT);
}
static uint16_t measure_color(uint8_t r,uint8_t g,uint8_t b){
    rgb_set(r?RGB_LEVEL:0, g?RGB_LEVEL:0, b?RGB_LEVEL:0);
    _delay_ms(5);
    uint32_t acc=0;
    for(uint8_t i=0;i<SAMPLES_PER_COLOR;i++){ acc+=adc_read_once(LDR_CH); _delay_ms(SAMPLE_DELAY_MS); }
    rgb_off(); return (uint16_t)(acc/SAMPLES_PER_COLOR);
}
static void measure_triplet_u16(uint16_t m[3]){
    uint16_t amb = ambient_avg();
    uint16_t R = measure_color(1,0,0);
    uint16_t G = measure_color(0,1,0);
    uint16_t B = measure_color(0,0,1);
    m[0]=sub_sat(R,amb); m[1]=sub_sat(G,amb); m[2]=sub_sat(B,amb);
}

static uint8_t chroma8_from_u16(const uint16_t in[3], uint8_t out[3]){
    uint32_t s=(uint32_t)in[0]+in[1]+in[2];
    if(s < MIN_SUM_ADC){ out[0]=out[1]=out[2]=0; return 0; }
    out[0]=(uint8_t)((in[0]*255UL)/s);
    out[1]=(uint8_t)((in[1]*255UL)/s);
    out[2]=(uint8_t)((in[2]*255UL)/s);
    return 1;
}
static uint8_t hue_sat_from_rgb8(uint8_t r, uint8_t g, uint8_t b, uint16_t* hue_deg, uint8_t* sat){
    uint8_t max=r; if(g>max) max=g; if(b>max) max=b;
    uint8_t min=r; if(g<min) min=g; if(b<min) min=b;
    uint8_t delta=max-min;
    if(max==0){ *sat=0; *hue_deg=0; return 0; }
    *sat=(uint8_t)(((uint16_t)delta*255U)/max);
    if(delta==0){ *hue_deg=0; return 0; }
    int32_t h;
    if(max==r)      h =   0 + 60*(int32_t)((int16_t)g-(int16_t)b)/delta;
    else if(max==g) h = 120 + 60*(int32_t)((int16_t)b-(int16_t)r)/delta;
    else            h = 240 + 60*(int32_t)((int16_t)r-(int16_t)g)/delta;
    while(h<0) h+=360; while(h>=360) h-=360;
    *hue_deg=(uint16_t)h; return 1;
}
static inline uint16_t circ_mid(uint16_t a,uint16_t b){
    int16_t d=(int16_t)b-(int16_t)a; while(d<-180)d+=360; while(d>180)d-=360;
    int16_t m=(int16_t)a + d/2; while(m<0)m+=360; while(m>=360)m-=360; return (uint16_t)m;
}
static inline uint16_t circ_dist(uint16_t a,uint16_t b){
    int16_t d=(int16_t)a-(int16_t)b; while(d<-180)d+=360; while(d>180)d-=360; if(d<0)d=-d; return (uint16_t)d;
}

// balance blancos y balance led

static void apply_white_balance(const uint16_t in[3], uint16_t out[3]){
    if(!wb_ok){ out[0]=in[0]; out[1]=in[1]; out[2]=in[2]; return; }
    uint32_t s=(uint32_t)wb_ref[0]+wb_ref[1]+wb_ref[2];
    if(s==0){ out[0]=in[0]; out[1]=in[1]; out[2]=in[2]; return; }
    uint32_t tgt=s/3;
    for(uint8_t i=0;i<3;i++){ uint32_t den=wb_ref[i]?wb_ref[i]:1; uint32_t v=(uint32_t)in[i]*tgt/den; if(v>65535U)v=65535U; out[i]=(uint16_t)v; }
}
static void wb_calibrate(void){
    uint16_t raw[3]; measure_triplet_u16(raw);
    wb_ref[0]=raw[0]; wb_ref[1]=raw[1]; wb_ref[2]=raw[2]; wb_ok=1;
    uart_printf("WB blanco RAW: R=%u G=%u B=%u\r\n> ", wb_ref[0],wb_ref[1],wb_ref[2]);
}

static uint8_t gain_from_pair(uint16_t x,uint16_t tgt){ if(x==0) return 255; uint32_t v=(uint32_t)RGB_LEVEL*tgt/x; if(v>255)v=255; return (uint8_t)v; }
static void led_balance_calibrate(void){
    uint16_t amb = ambient_avg();
    rgb_set_raw(255,0,0); _delay_ms(5); uint32_t aR=0; for(uint8_t i=0;i<SAMPLES_PER_COLOR;i++){ aR+=adc_read_once(LDR_CH); _delay_ms(SAMPLE_DELAY_MS); } rgb_off();
    rgb_set_raw(0,255,0); _delay_ms(5); uint32_t aG=0; for(uint8_t i=0;i<SAMPLES_PER_COLOR;i++){ aG+=adc_read_once(LDR_CH); _delay_ms(SAMPLE_DELAY_MS); } rgb_off();
    rgb_set_raw(0,0,255); _delay_ms(5); uint32_t aB=0; for(uint8_t i=0;i<SAMPLES_PER_COLOR;i++){ aB+=adc_read_once(LDR_CH); _delay_ms(SAMPLE_DELAY_MS); } rgb_off();
    uint16_t r0=sub_sat((uint16_t)(aR/SAMPLES_PER_COLOR),amb);
    uint16_t g0=sub_sat((uint16_t)(aG/SAMPLES_PER_COLOR),amb);
    uint16_t b0=sub_sat((uint16_t)(aB/SAMPLES_PER_COLOR),amb);
    uint32_t s=(uint32_t)r0+g0+b0; if(s<3){ uart_puts("LED balance: poca luz\r\n> "); return; }
    uint16_t tgt=(uint16_t)(s/3);
    levR=gain_from_pair(r0,tgt); levG=gain_from_pair(g0,tgt); levB=gain_from_pair(b0,tgt);
    uart_printf("LED balance: rawW R=%u G=%u B=%u -> levR=%u levG=%u levB=%u\r\n> ",
                r0,g0,b0, levR,levG,levB);
}

