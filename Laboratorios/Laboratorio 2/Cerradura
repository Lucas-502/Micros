#define PCF8574	0x27

#ifndef F_CPU
#define F_CPU 16000000UL
#endif
#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>//       
#include <xc.h>
 
#include <util/twi.h>
#include "twi_lcd.h"
#include "twi.h"
#include <stdbool.h>   // <<< necesario para bool/true/false

//Puertos

const uint8_t F4      = (1 << PD2);//Fila4
const uint8_t F3      = (1 << PD3);
const uint8_t F2      = (1 << PD4);
const uint8_t F1      = (1 << PD5);//Fila1
const uint8_t C1      = (1 << PD6);//columna1
const uint8_t C2      = (1 << PD7);
const uint8_t C3      = (1 << PB0);
const uint8_t C4      = (1 << PB1);//Columna4

const uint8_t Buzzer  = (1 << PB2);
const uint8_t Red     = (1 << PB3);    //Led rojo
const uint8_t Green   = (1 << PB4);    //Led verde

// Conmutador de PIN por olvido
#define NOMEACUERDOQUEPUSE 0
 
// Funciones de EEPROM de 328P
static void eew(uint16_t a, uint8_t d){
    while (EECR & (1<<EEPE));
    EEAR=a; EEDR=d; EECR |= (1<<EEMPE); EECR |= (1<<EEPE);
}

static uint8_t eer(uint16_t a){
    while (EECR & (1<<EEPE));
    EEAR=a; EECR |= (1<<EERE); return EEDR;
}

/ Mapa de teclado y buffers de ingreso
// Teclas simb칩licas
#define T_OK   'A'  // Aceptar  
#define T_BOR  'B'  // Borrar   
#define T_CAN  'C'  // Cancelar 
#define T_CER  'R'  // Cerrar   
#define T_MEN  'M'  // Menu (a la derecha del cero)
 
// Par치metros de longitud y reintentos
#define LMIN 4
#define LMAX 6
#define MAXI 3
 
// Disposici칩n de teclas (col x fila)
static const char teclas[4][4] = {
     { '1','4','7','*' },           // C1
     { '2','5','8','0' },           // C2
     { '3','6','9',T_MEN },         // C3
     { T_OK, T_BOR, T_CAN, T_CER }  // C4
};
 
static const uint8_t b[4] = { C1, C2, C3, C4 };
static const uint8_t f[4] = { F1, F2, F3, F4 };
 
// Buffers de ingreso
static char ing[LMAX];
static uint8_t n_ing=0;
static uint8_t ver=0;                
static volatile uint8_t want_cerrar=0;
static volatile uint8_t want_menu=0;

typedef enum { E_BIENV=0, E_VERIF, E_MENU, E_CAMB1, E_CAMB2, E_CIERRE } EST;
 
static void pant_bienvenido(void){
    twi_lcd_clear();
    twi_lcd_cmd(0x80); twi_lcd_msg("Bienvenido");
}
static void pant_opciones(void){
    twi_lcd_cmd(0xC0); twi_lcd_msg("A:Entrar M:Menu");
}
static void pant_pedir(const char *titulo){
    twi_lcd_clear();
    twi_lcd_cmd(0x80); twi_lcd_msg(titulo); /* <=16 */
}
static void pant_ok(void){
    twi_lcd_clear();
    twi_lcd_cmd(0x80); twi_lcd_msg("Acceso concedido");
}
static void pant_err(void){
    twi_lcd_clear();
    twi_lcd_cmd(0x80); twi_lcd_msg("Clave invalida");
}
static void pant_int(uint8_t n){
    twi_lcd_cmd(0xC0); twi_lcd_msg("Intento ");
    twi_lcd_dwr('0'+n); twi_lcd_msg("/3");
}
static void pant_alerta(void){
    twi_lcd_clear();
    twi_lcd_cmd(0x80); twi_lcd_msg("ALERTA! 3 fallos");
}
static void pant_cierre(void){
    twi_lcd_clear();
    twi_lcd_cmd(0x80); twi_lcd_msg("Cerrando...");
}

static char Teclado(void){
    PORTD |= (C1|C2);
    PORTB |= (C3|C4);
 
    for(uint8_t i=0;i<4;i++){
        if(i<2){ PORTD |= (C1|C2); PORTD &= ~b[i]; }
        else    { PORTB |= (C3|C4); PORTB &= ~b[i]; }
        _delay_us(5);
        for(uint8_t j=0;j<4;j++){                               
            if( !(PIND & f[j]) ){
                char t = teclas[i][j];
                _delay_ms(20); // antirrebote sencillo
                if(t != '*'){
                    while( !(PIND & f[j]) ) { _delay_ms(1); }
                }
                if(i<2) PORTD |= b[i]; else PORTB |= b[i];
                return t;
            }
        }
        if(i<2) PORTD |= b[i]; else PORTB |= b[i];
    }
    return 0;
}

// Pintado y rutina de pedir clave 
static void pintar_ing(void){
    twi_lcd_cmd(0xC0);
    for(uint8_t i=0;i<LMAX;i++){
        char c = (i<n_ing) ? (ver ? ing[i] : '*') : '_';
        twi_lcd_dwr(c);
        if(i<LMAX-1) twi_lcd_dwr(' ');
    }
    for(uint8_t k=11; k<16; k++) twi_lcd_dwr(' ');
}
 
static bool pedir_clave(const char *titulo){
    n_ing=0; ver=0;
    pant_pedir(titulo);
    pintar_ing();
 
    for(;;){
        char t = Teclado();
        if(!t){
            if(ver){
                while( (PIND & (F1|F2|F3|F4)) != (F1|F2|F3|F4) ){
                    pintar_ing();
                    _delay_ms(10);
                }
                ver=0; pintar_ing();
            }
            continue;
        }
 
        if(t==T_CER){ want_cerrar=1; return false; }   
        if(t==T_MEN){ want_menu=1;   return false; } 
        if(t==T_CAN){               return false; }  
 
        if(t>='0' && t<='9'){
            if(n_ing<LMAX){ ing[n_ing++]=t; pintar_ing(); }
        }else if(t==T_BOR){
            if(n_ing>0){ n_ing--; pintar_ing(); }
        }else if(t=='*'){
            ver=1; pintar_ing(); 
        }else if(t==T_OK){
            if(n_ing>=LMIN && n_ing<=LMAX) return true;
            twi_lcd_cmd(0x80); twi_lcd_msg("Longitud 4-6");
            _delay_ms(700);
            twi_lcd_cmd(0x80); twi_lcd_msg(titulo);
            pintar_ing();
        }
    }
}

static EST est_bienv(void){
    pant_bienvenido();
    _delay_ms(700);
    pant_opciones();
 
    while(1){
        char t = Teclado();
        if(!t) continue;
        if(t==T_CER) return E_CIERRE; 
        if(t==T_MEN) return E_MENU;
        if(t==T_OK)  return E_VERIF;
    }
}
 
// Estado: Verificaci칩n (3 intentos)
static EST est_verif(void){
    uint8_t intentos=0;
 
    while(1){
        bool ok = pedir_clave("Clave (4-6):   ");
        if(want_cerrar){ want_cerrar=0; return E_CIERRE; }
        if(want_menu){   want_menu=0;   return E_MENU;  }
        if(!ok) return E_BIENV;
 
        uint8_t lg = eer(0x00);
        bool eq = (n_ing==lg) && (lg>=LMIN && lg<=LMAX);
        for(uint8_t i=0;i<lg && eq;i++){
            if(ing[i] != eer(0x01+i)) eq=false;
        }
 
        if(eq){
            pant_ok();
            PORTB |= LV; 
            PORTB &= ~LR;
            _delay_ms(800);
            PORTB &= ~LV;
            PORTB |= BUZ; _delay_ms(100); PORTB &= ~BUZ;
            _delay_ms(900);
            return E_BIENV;
        }else{
            intentos++;
            pant_err();
            pant_int(intentos);
            PORTB |= LR;
            PORTB &= ~LV;
            _delay_ms(800);
            PORTB &= ~LR;
            PORTB |= BUZ; _delay_ms(80); PORTB &= ~BUZ; _delay_ms(80);
            PORTB |= BUZ; _delay_ms(80); PORTB &= ~BUZ;
            _delay_ms(800);
            if(intentos>=MAXI){
                pant_alerta();
                for(uint8_t i=0;i<4;i++){
                    PORTB |= LR; PORTB |= BUZ; _delay_ms(200);
                    PORTB &= ~BUZ; PORTB &= ~LR; _delay_ms(130);
                }
                return E_BIENV;
            }
        }
    }
}
