#ifndef F_CPU
#define F_CPU 16000000UL
#endif
 
#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>
#include <math.h>
#include <avr/pgmspace.h>
#include "zorr-1_compacto_r2_3.h"
#include "Screenshot-2025-10-03-155654_compacto_r2_3.h"
 
static void uartInicio(void){
	UBRR0H = 0;
	UBRR0L = 103;
	UCSR0A = 0;
	UCSR0B = (1<<TXEN0) | (1<<RXEN0);
	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
}
static void uartChar(char c){
	while(!(UCSR0A & (1<<UDRE0)));
	UDR0 = c;
}
static void uartTxt(const char* s){
	while(*s) uartChar(*s++);
}
static void uartNum(uint16_t n){
	if(n==0){ uartChar('0'); return; }
	char buf[8]; uint8_t i=0;
	while(n){ buf[i++] = '0' + (n%10); n/=10; }
	while(i--) uartChar(buf[i]);
}
static char uartLeer(void){
	while(!(UCSR0A & (1<<RXC0)));
	return UDR0;
}
 
void MenuUart(uint8_t e);
void Timer(uint16_t t);
void Controldepines(void);
void Cruz(void);
void Triangulo(void);
void Circulo(void);
void Murcielago(void);
void Zorro(void);
void Linea_con_angulo(void);
void Diagonal135(uint16_t t);
void Diagonal225(uint16_t t);
void linea_Curva(void);
void izquierda(uint16_t t);
void abajo(uint16_t t);
void Linea_con_angulo(uint16_t t, float angulo_grados);

const uint8_t LAPIZAR = (1 << PD2);
const uint8_t LAPIZAB = (1 << PD3);
const uint8_t ARR     = (1 << PD4);
const uint8_t ABB     = (1 << PD5);
const uint8_t IZQ     = (1 << PD6);
const uint8_t DER     = (1 << PD7);
 
void MenuUart(uint8_t e){
	uartTxt("\r\n=== MENU ===\r\n");
	uartTxt("0: circulo\r\n");
	uartTxt("1: cruz\r\n");
	uartTxt("2: triangulo\r\n");
	uartTxt("3: murcielago\r\n");
	uartTxt("4: zorro\r\n");
	uartTxt("Elija numero y Enter...\r\n");
}
void Timer(uint16_t t){
	while(t--){ _delay_ms(1); }
}

static void bajar_lapiz(void);
static void subir_lapiz(void);
static void Linea_con_angulo(uint16_t t, float angulo_grados);
 
static void ejecutar_compacto_escalado(const uint8_t* data, uint16_t nbytes,
                                       uint8_t num, uint8_t den,
                                       uint8_t t10_min, uint8_t t10_max){
    if (den == 0) den = 1;
    uint16_t i = 0;
    while (i < nbytes){
        uint8_t b = pgm_read_byte(&data[i++]);
 
        if (b == 0xFE){
            bajar_lapiz();
        } else if (b == 0xFF){
            subir_lapiz();
        } else {
            if (i >= nbytes) break;
            uint8_t t10 = pgm_read_byte(&data[i++]);
            uint16_t t10s = (uint16_t)((uint32_t)t10 * num + (den/2)) / den;
            if (t10s < t10_min) t10s = t10_min;
            if (t10s > t10_max) t10s = t10_max;
 
            float ang = (float)b * (360.0f/254.0f);
            uint16_t t_ms = (uint16_t)t10s * 10u;
            Linea_con_angulo(t_ms, ang);
        }
    }
}

void bajar_lapiz(void){
	PORTD |=  LAPIZAR;
	PORTD &= ~LAPIZAB;
}
void subir_lapiz(void){
	PORTD |=  LAPIZAB;
	PORTD &= ~LAPIZAR;
}
void arriba(uint16_t t){
	PORTD |=  ABB;
	PORTD &= ~ARR;
	Timer(t);
	PORTD |=  ARR;
}
void abajo(uint16_t t){
	PORTD |=  ARR;
	PORTD &= ~ABB;
	Timer(t);
	PORTD |=  ABB;
}
void izquierda(uint16_t t){
	PORTD |=  DER;
	PORTD &= ~IZQ;
	Timer(t);
	PORTD |=  IZQ;
}
void derecha(uint16_t t){
	PORTD |=  IZQ;
	PORTD &= ~DER;
	Timer(t);
	PORTD |=  DER;
}

//  Línea por ángulo y diagonales
void Linea_con_angulo(uint16_t t, float angulo_grados){
    const uint16_t PASO_MS    = 10;
    const uint16_t VENTANA_MS = PASO_MS * 10;
    const uint8_t  TICKS_VENT = (uint8_t)(VENTANA_MS / PASO_MS);
 
    const float porcentaje_max = 0.92f;
    const float umbral_minimo  = 0.03f;
 
    float a = fmodf(angulo_grados, 360.0f);
    if (a < 0.0f) a += 360.0f;
    float rad = a * (float)M_PI / 180.0f;
    float comp_x = cosf(rad);
    float comp_y = sinf(rad);
 
    uint8_t pinX_activo = (comp_x >= 0.0f) ? DER : IZQ;
    uint8_t pinY_activo = (comp_y >= 0.0f) ? ARR : ABB;
 
    float ax = fabsf(comp_x), ay = fabsf(comp_y);
    int ticks_x = (int)((porcentaje_max * ax * (float)VENTANA_MS + 0.5f) / (float)PASO_MS);
    int ticks_y = (int)((porcentaje_max * ay * (float)VENTANA_MS + 0.5f) / (float)PASO_MS);
 
    if (ax > umbral_minimo && ticks_x == 0) ticks_x = 1;
    if (ay > umbral_minimo && ticks_y == 0) ticks_y = 1;
    if (ticks_x >= (int)TICKS_VENT) ticks_x = (int)TICKS_VENT - 1;
    if (ticks_y >= (int)TICKS_VENT) ticks_y = (int)TICKS_VENT - 1;
 
    uint16_t ticks_totales = (t / PASO_MS);
    if (ticks_totales == 0) ticks_totales = 1;
 
    uint8_t fase = 0;
    for(uint16_t k = 0; k < ticks_totales; ++k){
        PORTD |= (DER | IZQ | ARR | ABB);
        if (fase < (uint8_t)ticks_x) { PORTD &= ~pinX_activo; }
        if (fase < (uint8_t)ticks_y) { PORTD &= ~pinY_activo; }
        Timer(PASO_MS);
        fase++;
        if (fase >= TICKS_VENT) fase = 0;
    }
    PORTD |= (DER | IZQ | ARR | ABB);
}
void Diagonal225(uint16_t t){
	PORTD |=  DER; PORTD |=  ARR;
	PORTD &= ~ABB; PORTD &= ~IZQ;
	Timer(t);
	PORTD |=  ABB; PORTD |=  IZQ;
}
void Diagonal135(uint16_t t){
	PORTD |=  ABB; PORTD |=  DER;
	PORTD &= ~IZQ; PORTD &= ~ARR;
	Timer(t);
	PORTD |=  IZQ; PORTD |=  ARR;
}

extern const uint8_t ZORR_1_MOVS_R2_3_DATA[] PROGMEM;
#define ZORRO_BYTES  ZORR_1_MOVS_R2_3_BYTES
void Zorro(void){
    izquierda(3000);
    ejecutar_compacto_escalado(ZORR_1_MOVS_R2_3_DATA, ZORRO_BYTES, 1, 9, 1, 255);
}
extern const uint8_t SCREENSHOT_2025_10_03_155654_MOVS_R2_3_DATA[] PROGMEM;
#define MURCI_BYTES  SCREENSHOT_2025_10_03_155654_MOVS_R2_3_BYTES
void Murcielago(void){
    izquierda(3000);
    ejecutar_compacto_escalado(SCREENSHOT_2025_10_03_155654_MOVS_R2_3_DATA, MURCI_BYTES, 1, 5, 1, 255);
}

void Cruz(void){
	izquierda(3000);
	bajar_lapiz();
	_delay_ms(200);
	Diagonal225(3000);
	subir_lapiz();
	derecha(3000);
	bajar_lapiz();
	Diagonal135(3000);
	subir_lapiz();
}
void Triangulo(void){
	abajo(3000);
	bajar_lapiz();
	_delay_ms(300);
	Diagonal225(3000);
	derecha(6000);
	Diagonal135(3000);
	_delay_ms(300);
	subir_lapiz();
}
