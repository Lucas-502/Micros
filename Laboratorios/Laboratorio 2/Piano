#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>
#include <stdbool.h>

// UART 
#define BAUD 9600UL
#define UBRR_VAL ((F_CPU/(16UL*BAUD))-1)

static inline void uart_init(void){
    UBRR0H = (uint8_t)(UBRR_VAL>>8);
    UBRR0L = (uint8_t)(UBRR_VAL);
    UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
}
static inline uint8_t uart_available(void){ return (UCSR0A&(1<<RXC0)); }
static inline char uart_getchar_nb(void){ return uart_available()? UDR0 : '\0'; }
static inline void uart_putchar(char c){ while(!(UCSR0A&(1<<UDRE0))); UDR0=c; }
static void uart_puts(const char* s){ while(*s) uart_putchar(*s++); }

// PWM (ICR1)
static inline void pwm_stop(void){
    TCCR1A=0; TCCR1B=0;
    PORTB &= ~(1<<PB1);
}
static inline void pwm_set_icr(uint16_t top){
    if(!top){ pwm_stop(); return; }
    DDRB  |= (1<<PB1);
    TCCR1A = (1<<COM1A1) | (1<<WGM11);
    TCCR1B = (1<<WGM12) | (1<<WGM13) | (1<<CS11);
    ICR1   = top;
    OCR1A  = (top+1)/2; /* ~50% */
}

// Notas
enum Note { REST=0, C4,D4,E4,F4,G4,A4,B4,  C5,D5,E5,F5,G5,A5,B5,  C6,D6,E6 };
static const uint16_t ICR_TAB[] = {
    /* REST */ 0,
    /* C4..B4 */ 7644, 6811, 6067, 5727, 5102, 4546, 4050,
    /* C5..B5 */ 3822, 3405, 3034, 2863, 2551, 2273, 2025,
    /* C6..E6 */ 1910, 1702, 1516
};
static inline void pwm_note(enum Note n){ pwm_set_icr(ICR_TAB[n]); }

// Entradas del teclado
static inline void entradas_init(void){
    DDRD &= ~((1<<PD2)|(1<<PD3)|(1<<PD4)|(1<<PD5)|(1<<PD6)|(1<<PD7));
    PORTD &= ~((1<<PD2)|(1<<PD3)|(1<<PD4)|(1<<PD5)|(1<<PD6)|(1<<PD7));
    DDRB &= ~(1<<PB0); PORTB &= ~(1<<PB0);
    DDRC &= ~(1<<PC0); PORTC &= ~(1<<PC0);
}
static inline uint8_t leer_crudo(void){
    if(PIND&(1<<PD2)) return 0;
    if(PIND&(1<<PD3)) return 1;
    if(PIND&(1<<PD4)) return 2;
    if(PIND&(1<<PD5)) return 3;
    if(PIND&(1<<PD6)) return 4;
    if(PIND&(1<<PD7)) return 5;
    if(PINB&(1<<PB0)) return 6;
    if(PINC&(1<<PC0)) return 7;
    return 0xFF;
}
#define DB_CNT 20
static uint8_t nota_estable(void){
    static uint8_t cand=0xFF, est=0xFF, cnt=0;
    uint8_t v=leer_crudo();
    if(v==cand){ if(cnt<DB_CNT) cnt++; if(cnt==DB_CNT && est!=v){ est=v; return est; } }
    else{ cand=v; cnt=0; }
    return 0xFE;
}
// Canciones
#define MAX_NOTAS 96
typedef struct{
    uint8_t  nota_idx[MAX_NOTAS];
    uint16_t dur_ms [MAX_NOTAS];
    uint16_t len;
} Cancion;

static Cancion song1, song2;
static uint8_t reproduciendo=0;
static uint16_t i_note=0, t_cnt=0;
static uint8_t modo_teclado=1;

// Auxiliar de líneas para construir canciones
typedef struct { const uint8_t *n; const uint8_t *d; uint16_t len; } Line;

// Cancion 1 Parte A
static const uint8_t A1_note[] = { F5, A5, B5 };
static const uint8_t A1_dur[]  = { 4,  4,  7  };
static const uint8_t A2_note[] = { F5, A5, B5 };
static const uint8_t A2_dur[]  = { 4,  4,  7  };
static const uint8_t A3_note[] = { F5, A5, B5, E6, D6 };
static const uint8_t A3_dur[]  = { 4,  4,  5,  4,  9  };
static const uint8_t A4_note[] = { B5, C6, B5, G5, E5 };
static const uint8_t A4_dur[]  = { 4,  5,  4,  4,  10 };
static const uint8_t A5_note[] = { D5, E5, G5, E5 };
static const uint8_t A5_dur[]  = { 4,  4,  4,  8 };
static const Line LINES_A[] = {
  {A1_note,A1_dur,sizeof(A1_note)}, {A2_note,A2_dur,sizeof(A2_note)},
  {A3_note,A3_dur,sizeof(A3_note)}, {A4_note,A4_dur,sizeof(A4_note)},
  {A5_note,A5_dur,sizeof(A5_note)}
};

// Cancion 1 Parte B
static const uint8_t B1_note[] = { F5, A5, B5 };
static const uint8_t B1_dur[]  = { 4,  4,  7  };
static const uint8_t B2_note[] = { F5, A5, B5 };
static const uint8_t B2_dur[]  = { 4,  4,  7  };
static const uint8_t B3_note[] = { F5, A5, B5, E6, D6 };
static const uint8_t B3_dur[]  = { 4,  4,  5,  4,  10 };
static const uint8_t B4_note[] = { B5, C6, E6, B5, G5 };
static const uint8_t B4_dur[]  = { 4,  4,  4,  5,  11 };
static const uint8_t B5_note[] = { B5, G5, D5, E5 };
static const uint8_t B5_dur[]  = { 4,  5,  4,  15 };
static const Line LINES_B[] = {
 {B1_note,B1_dur,sizeof(B1_note)}, {B2_note,B2_dur,sizeof(B2_note)},
  {B3_note,B3_dur,sizeof(B3_note)}, {B4_note,B4_dur,sizeof(B4_note)},
  {B5_note,B5_dur,sizeof(B5_note)}
};
// Tiempos totales independientes para A y B
#define TOTAL_MS_A 6000
#define TOTAL_MS_B 6000

// Cancion 2

static const uint8_t C1_note[] = { B5,B5,B5 };
static const uint8_t C1_dur[]  = { 3, 3, 6 };
static const uint8_t C2_note[] = { D6,C6,B5,B5,B5 };
static const uint8_t C2_dur[]  = { 2, 2, 3, 3, 6 };
static const uint8_t C3_note[] = { D6,C6,B5,B5,B5 };
static const uint8_t C3_dur[]  = { 2, 2, 3, 3, 6 };
static const uint8_t C4_note[] = { D6,C6 };
static const uint8_t C4_dur[]  = { 6, 6 };
static const uint8_t C5_note[] = { B5,B5,E5,B5 };
static const uint8_t C5_dur[]  = { 3, 3, 6, 6 };
static const uint8_t C6_note[] = { E5,B5 };
static const uint8_t C6_dur[]  = { 8, 8 };

static const Line LINES_C[] = {
  {C1_note,C1_dur,sizeof(C1_note)}, {C2_note,C2_dur,sizeof(C2_note)},
  {C3_note,C3_dur,sizeof(C3_note)}, {C4_note,C4_dur,sizeof(C4_note)},
  {C5_note,C5_dur,sizeof(C5_note)}, {C6_note,C6_dur,sizeof(C6_note)}
};
#define TOTAL_MS_C 7000

// helpers de tiempo compartidos
static uint32_t sum_units(const Line *L, uint8_t n){
    uint32_t s=0; for(uint8_t i=0;i<n;i++) for(uint16_t j=0;j<L[i].len;j++) s+=L[i].d[j]; return s;
}
static uint16_t tick_ms_for(uint32_t total_ms, const Line *L, uint8_t n){
    uint32_t T=sum_units(L,n); if(!T) T=1;
    return (uint16_t)((total_ms + T/2)/T); 
}

// Build Canción 1 (A+B)
static void init_song1(void){
    const uint8_t nA = sizeof(LINES_A)/sizeof(LINES_A[0]);
    const uint8_t nB = sizeof(LINES_B)/sizeof(LINES_B[0]);
    const uint16_t tickA = tick_ms_for(TOTAL_MS_A, LINES_A, nA);
    const uint16_t tickB = tick_ms_for(TOTAL_MS_B, LINES_B, nB);

    song1.len = 0;
    for(uint8_t i=0;i<nA;i++){
        for(uint16_t j=0;j<LINES_A[i].len && song1.len<MAX_NOTAS; j++){
            song1.nota_idx[song1.len] = LINES_A[i].n[j];
            song1.dur_ms [song1.len]  = (uint16_t)LINES_A[i].d[j]*tickA;
            song1.len++;
        }
    }
    for(uint8_t i=0;i<nB;i++){
        for(uint16_t j=0;j<LINES_B[i].len && song1.len<MAX_NOTAS; j++){
            song1.nota_idx[song1.len] = LINES_B[i].n[j];
            song1.dur_ms [song1.len]  = (uint16_t)LINES_B[i].d[j]*tickB;
            song1.len++;
        }
    }
}




static void init_song2(void){
    const uint8_t nC = sizeof(LINES_C)/sizeof(LINES_C[0]);
    const uint16_t tickC = tick_ms_for(TOTAL_MS_C, LINES_C, nC);
    const uint8_t REP_C = 3;  /* ? repetir 3 veces */

    song2.len = 0;
    for(uint8_t rep=0; rep<REP_C; rep++){
        for(uint8_t i=0; i<nC; i++){
            for(uint16_t j=0; j<LINES_C[i].len; j++){
                if(song2.len >= MAX_NOTAS) goto fin_c2;  /* seguridad */
                song2.nota_idx[song2.len] = LINES_C[i].n[j];
                song2.dur_ms [song2.len]  = (uint16_t)LINES_C[i].d[j]*tickC;
                song2.len++;
            }
        }
    }
fin_c2:
    ;
}

//Reproductor:

static void start_song(uint8_t n){
    reproduciendo = n; i_note=0; t_cnt=0; modo_teclado = 0;
    uart_puts("\r\n>>> Reproduciendo cancion ");
    uart_putchar('0'+n); uart_puts("...\r\n");
}
static void stop_song(void){
    reproduciendo=0; i_note=0; t_cnt=0; pwm_stop();
    uart_puts("\r\n>>> Reproduccion detenida\r\n");
}
static void step_player(void){
    if(!reproduciendo) return;
    Cancion* s = (reproduciendo==1)? &song1 : &song2;
    if(i_note >= s->len){
        stop_song(); uart_puts(">>> Cancion finalizada\r\n"); modo_teclado=1; return;
    }
    if(t_cnt==0) pwm_note((enum Note)s->nota_idx[i_note]);
    t_cnt++;
    if(t_cnt >= s->dur_ms[i_note]){
        pwm_stop(); _delay_ms(20);
        i_note++; t_cnt=0;
    }
}

static void mostrar_menu(void){                                                             //menu uart
    uart_puts("  PIANO ELECTRONICO \r\n");
    uart_puts("\nCOMANDOS:\r\n");
    uart_puts("  C1 o 1 : Cancion 1\r\n");
    uart_puts("  C2 o 2 : Cancion 2 \r\n");
    uart_puts("  S      : Detener\r\n");
    uart_puts("  T      : Teclado manual\r\n");
    uart_puts("  M      : Mostrar menu\r\n");
}
static inline void str_to_upper(char* s){
    for(; *s; ++s){ if(*s>='a' && *s<='z') *s -= 32; }
}
static inline void rstrip_ws(char* s){
    uint8_t i=0; while(s[i]) i++;
    while(i>0 && (s[i-1]==' '||s[i-1]=='\t')) { s[i-1]='\0'; i--; }
}
static void procesar_comando_linea(char* cmd){
    rstrip_ws(cmd);
    str_to_upper(cmd);

    if((cmd[0]=='C' && cmd[1]=='1' && cmd[2]=='\0') || (cmd[0]=='1' && cmd[1]=='\0')){
        uart_puts("[C1]\r\n"); start_song(1); return;
    }
    if((cmd[0]=='C' && cmd[1]=='2' && cmd[2]=='\0') || (cmd[0]=='2' && cmd[1]=='\0')){
        uart_puts("[C2]\r\n"); start_song(2); return;
    }
    if(cmd[0]=='S' && cmd[1]=='\0'){ uart_puts("[S]\r\n"); stop_song(); modo_teclado=1; return; }
    if(cmd[0]=='T' && cmd[1]=='\0'){ uart_puts("[T]\r\n"); stop_song(); modo_teclado=1; uart_puts(">>> Modo teclado manual activado\r\n"); return; }
    if(cmd[0]=='M' && cmd[1]=='\0'){ uart_puts("[M]\r\n"); mostrar_menu(); return; }

    uart_puts(">>> Comando no reconocido. Opciones: 1,C1, 2,C2, S, T, M\r\n");
}

static uint8_t procesar_atajo(char c){
    if(c>='a' && c<='z') c -= 32;
    if(c=='1'){ uart_puts("\r\n[C1]\r\n"); start_song(1); return 1; }
    if(c=='2'){ uart_puts("\r\n[C2]\r\n"); start_song(2); return 1; }
    if(c=='S'){ uart_puts("\r\n[S]\r\n"); stop_song(); modo_teclado=1; return 1; }
    if(c=='T'){ uart_puts("\r\n[T]\r\n"); stop_song(); modo_teclado=1; uart_puts(">>> Modo teclado manual activado\r\n"); return 1; }
    if(c=='M'){ uart_puts("\r\n[M]\r\n"); mostrar_menu(); return 1; }
    return 0;
}

int main(void){
    entradas_init(); uart_init();
    init_song1(); init_song2();
    _delay_ms(100);
    mostrar_menu();


    #define CMD_MAX 16
    char linea[CMD_MAX]; 
    uint8_t lin_len=0;

    /* Teclado */
    uint8_t ultima_nota = 0xFF;

    while(1){
        char c = uart_getchar_nb();
        if(c != '\0'){
            /* Echo de depuración “visible” */
            if(c=='\r') { uart_puts("\\r"); }
            else if(c=='\n'){ uart_puts("\\n"); }
            else if(c==8 || c==127){ /* backspace */
                if(lin_len>0){ lin_len--; uart_puts("\b \b"); }
            }else{
                uart_putchar(c);
            }

            /* Atajos sin Enter */
            if(procesar_atajo(c)){ lin_len=0; }

            /* Enter (CR o LF o CRLF) */
            if(c=='\r' || c=='\n'){
                if(lin_len>0){
                    linea[lin_len]='\0';
                    uart_puts("\r\n");
                    procesar_comando_linea(linea);
                }
                lin_len=0;
            }
            /* Cargar buffer de línea */
            else if(c >= ' ' && c <= '~'){
                if(lin_len < CMD_MAX-1){
                    linea[lin_len++] = c;
                }else{
                    linea[lin_len]='\0';
                    uart_puts("\r\n");
                    procesar_comando_linea(linea);
                    lin_len=0;
                }
            }
        }
        if(modo_teclado && !reproduciendo){
            uint8_t r = nota_estable();
            if(r != 0xFE){
                if(r < 8){
                    if(r != ultima_nota){
                        pwm_note((enum Note)(C4 + r));
                        uart_puts(">>> Tocando: ");
                        static const char* nombres[8] = {
                            "Do(C4)", "Re(D4)", "Mi(E4)", "Fa(F4)",
                            "Sol(G4)", "La(A4)", "Si(B4)", "Do(C5)"
                        };
                        uart_puts(nombres[r]); uart_puts("\r\n");
                        ultima_nota = r;
                    }
                }else{
                    pwm_stop();
                    ultima_nota = 0xFF;
                }
            }
        }
        if(reproduciendo){
            step_player();
        }

        _delay_ms(1);
    }
}
