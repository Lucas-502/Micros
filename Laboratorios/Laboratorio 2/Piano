#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>
#include <stdbool.h>

/* UART */
#define BAUD 9600UL
#define UBRR_VAL ((F_CPU/(16UL*BAUD))-1)

static inline void uart_init(void){
    UBRR0H = (uint8_t)(UBRR_VAL>>8);
    UBRR0L = (uint8_t)(UBRR_VAL);
    UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
}
static inline uint8_t uart_available(void){ return (UCSR0A&(1<<RXC0)); }
static inline char uart_getchar_nb(void){ return uart_available()? UDR0 : '\0'; }
static inline void uart_putchar(char c){ while(!(UCSR0A&(1<<UDRE0))); UDR0=c; }
static void uart_puts(const char* s){ while(*s) uart_putchar(*s++); }

/* ================ PWM (ICR1) ================= */
/* Modo 14: FAST-PWM TOP=ICR1; f = F_CPU/(N*(1+ICR1)), N=8 ? ICR1?2e6/f - 1 */
static inline void pwm_stop(void){
    TCCR1A=0; TCCR1B=0;
    PORTB &= ~(1<<PB1);
}
static inline void pwm_set_icr(uint16_t top){
    if(!top){ pwm_stop(); return; }
    DDRB  |= (1<<PB1);
    TCCR1A = (1<<COM1A1) | (1<<WGM11);
    TCCR1B = (1<<WGM12) | (1<<WGM13) | (1<<CS11); /* prescaler 8 */
    ICR1   = top;
    OCR1A  = (top+1)/2; /* ~50% */
}

/* ======= Notas (tabla ICR exacta C4..E6) ======= */
enum Note { REST=0, C4,D4,E4,F4,G4,A4,B4,  C5,D5,E5,F5,G5,A5,B5,  C6,D6,E6 };
static const uint16_t ICR_TAB[] = {
    /* REST */ 0,
    /* C4..B4 */ 7644, 6811, 6067, 5727, 5102, 4546, 4050,
    /* C5..B5 */ 3822, 3405, 3034, 2863, 2551, 2273, 2025,
    /* C6..E6 */ 1910, 1702, 1516
};
static inline void pwm_note(enum Note n){ pwm_set_icr(ICR_TAB[n]); }

/* ================ Entradas teclado ================ */
static inline void entradas_init(void){
    DDRD &= ~((1<<PD2)|(1<<PD3)|(1<<PD4)|(1<<PD5)|(1<<PD6)|(1<<PD7));
    PORTD &= ~((1<<PD2)|(1<<PD3)|(1<<PD4)|(1<<PD5)|(1<<PD6)|(1<<PD7));
    DDRB &= ~(1<<PB0); PORTB &= ~(1<<PB0);
    DDRC &= ~(1<<PC0); PORTC &= ~(1<<PC0);
}
/* 0..7 (C4..B4) segÃºn prioridad grave?agudo; 0xFF = nada */
static inline uint8_t leer_crudo(void){
    if(PIND&(1<<PD2)) return 0;
    if(PIND&(1<<PD3)) return 1;
    if(PIND&(1<<PD4)) return 2;
    if(PIND&(1<<PD5)) return 3;
    if(PIND&(1<<PD6)) return 4;
    if(PIND&(1<<PD7)) return 5;
    if(PINB&(1<<PB0)) return 6;
    if(PINC&(1<<PC0)) return 7;
    return 0xFF;
}
/* Antirrebote simple */
#define DB_CNT 20
static uint8_t nota_estable(void){
    static uint8_t cand=0xFF, est=0xFF, cnt=0;
    uint8_t v=leer_crudo();
    if(v==cand){ if(cnt<DB_CNT) cnt++; if(cnt==DB_CNT && est!=v){ est=v; return est; } }
    else{ cand=v; cnt=0; }
    return 0xFE;
}

