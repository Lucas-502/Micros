.include "m328pdef.inc"

; Constantes
.equ DELAY_SCROLL = 250         ; velocidad del scroll (ajustable)
.equ NUM_LETRAS   = 14
.equ COL_VACIA    = 0x00       ; columna vacía entre letras

; Registros
.def temp     = r16
.def temp2    = r17
.def temp3    = r18
.def temp4    = r19
.def fila     = r20            ; 
.def columnas = r21            ; patrón de columnas actual
.def indice_letra = r22        ; índice de la letra actual
.def col_letra    = r23        ; columna dentro de la letra 
.def contador_delay = r24      ; para el retardo del scroll
.def buffer_col = r25          ; buffer para la columna entrante

.cseg
.org 0x0000
    rjmp inicio

; Bitmaps (8 bytes por letra, bit7=col1 .. bit0=col8)
.align 2
inte0: .db 0b001000,0b000000,0b001000,0b010000,0b100000,0b100010,0b100010,0b011100
H:     .db 0b100010,0b100010,0b100010,0b111110,0b100010,0b100010,0b100010,0b000000 
I:     .db 0b111110,0b001000,0b001000,0b001000,0b001000,0b001000,0b111110,0b000000
J:     .db 0b011110,0b000100,0b000100,0b000100,0b000100,0b100100,0b011000,0b000000
O:     .db 0b011110,0b100001,0b100001,0b100001,0b100001,0b100001,0b011110,0b000000 
esp:   .db 0b000000,0b000000,0b000000,0b000000,0b000000,0b000000,0b000000,0b000000
D1:    .db 0b111100,0b100010,0b100010,0b100010,0b100010,0b100010,0b111100,0b000000
E:     .db 0b111110,0b100000,0b100000,0b111100,0b100000,0b100000,0b111110,0b000000 
S:     .db 0b011100,0b100010,0b100000,0b011100,0b000010,0b100010,0b011100,0b000000  
inte:  .db 0b011100,0b100010,0b100010,0b000010,0b000100,0b001000,0b000000,0b001000 

tabla_letras:
    .dw inte0,H,I,J,O,esp,D1,E,esp,D1,I,O,S,inte

.align 2
CARITA_FELIZ:
    .db 0b00000000,0b00100100,0b00100100,0b00100100,0b10000001,0b01000010,0b00111100,0b00000000
CARITA_TRISTE:
    .db 0b00000000,0b00100100,0b00100100,0b00100100,0b00000000,0b00111100,0b01000010,0b10000001
ROMBO:
    .db 0b00011000,0b00111100,0b01111110,0b11111111,0b11111111,0b01111110,0b00111100,0b00011000
CORAZON:
    .db 0b00000000,0b01100110,0b11111111,0b11111111,0b11111111,0b01111110,0b00111100,0b00011000
ALIEN:
    .db 0b00011000,0b00111100,0b01111110,0b11011011,0b11111111,0b01011010,0b10000001,0b01000010

tabla_figuras:
    .dw CARITA_FELIZ, CARITA_TRISTE, ROMBO, CORAZON, ALIEN

; Buffer en RAM para las 8 filas actuales de la matriz
.dseg
.org 0x0100
matriz_buffer: .byte 8          ; 8 bytes, uno por fila

; Inicio
.cseg
inicio:
    ; Stack
    ldi  temp, high(RAMEND)
    out  SPH, temp
    ldi  temp, low(RAMEND)
    out  SPL, temp

    ; Configurar pines - filas y columnas como salida
    ldi  temp, 0xFC            ; PD7..PD2 salida (filas 0..5)
    out  DDRD, temp
    ldi  temp, 0x3F            ; PB5..PB0 salida (cols + filas 6/7)
    out  DDRB, temp
    ldi  temp, 0x3C            ; PC5..PC2 salida (cols 5..8)
    out  DDRC, temp

    ; LED indicador PD0
    sbi  DDRD, 0
    cbi  PORTD, 0

    ; Inicializar variables
    ldi  indice_letra, 0
    ldi  col_letra, 0
    ldi  contador_delay, DELAY_SCROLL

    ; Limpiar buffer inicial
    rcall limpiar_buffer

; Loop principal
main:
    ; Multiplexar la matriz actual varias veces
    rcall multiplexar_matriz
    
    ; Decrementar contador de delay
    dec  contador_delay
    brne main                   ; si no llegó a 0, seguir mostrando
    
    ; Reiniciar contador y hacer scroll
    ldi  contador_delay, DELAY_SCROLL
    rcall scroll_izquierda
    
    rjmp main

; Limpiar buffer (todas las filas a 0)
limpiar_buffer:
    push XL
    push XH
    push temp
    push temp2
    
    ldi  XL, low(matriz_buffer)
    ldi  XH, high(matriz_buffer)
    ldi  temp2, 8
limpiar_loop:
    ldi  temp, 0x00
    st   X+, temp
    dec  temp2
    brne limpiar_loop
    
    pop  temp2
    pop  temp
    pop  XH
    pop  XL
    ret

; Scroll a la izquierda - desplaza todo 1 bit y añade nueva columna
scroll_izquierda:
    push XL
    push XH
    push YL
    push YH
    push temp
    push temp2
    push temp3
    
    ; Obtener la siguiente columna a mostrar
    rcall obtener_siguiente_columna  ; resultado en temp3
    
    ; Desplazar cada fila del buffer 1 bit a la izquierda
    ldi  XL, low(matriz_buffer)
    ldi  XH, high(matriz_buffer)
    ldi  temp2, 0               ; contador de fila
    
scroll_fila:
    ld   temp, X                ; cargar fila actual
    lsl  temp                   ; desplazar a la izquierda
    
    ; Añadir el bit correspondiente de la nueva columna
    sbrc temp3, 0               ; si bit0 de temp3 es 1
    ori  temp, 0x01            ; poner bit0 del buffer
    
    st   X+, temp               ; guardar fila actualizada
    lsr  temp3                  ; siguiente bit de la columna
    
    inc  temp2
    cpi  temp2, 8
    brne scroll_fila
    
    ; Avanzar a la siguiente columna
    inc  col_letra
    cpi  col_letra, 9           ; 8 columnas + 1 espacio
    brlo no_nueva_letra
    
    ; Pasar a la siguiente letra
    ldi  col_letra, 0
    inc  indice_letra
    cpi  indice_letra, NUM_LETRAS
    brlo no_reset
    ldi  indice_letra, 0        ; volver al inicio del mensaje
    
no_reset:
no_nueva_letra:
    pop  temp3
    pop  temp2
    pop  temp
    pop  YH
    pop  YL
    pop  XH
    pop  XL
    ret

; Obtener la siguiente columna para añadir al scroll
; Resultado en temp3 (8 bits, uno por fila)
obtener_siguiente_columna:
    push ZL
    push ZH
    push temp
    push temp2
    
    ; Si col_letra == 8, devolver columna vacía (espacio entre letras)
    cpi  col_letra, 8
    brne no_espacio
    ldi  temp3, COL_VACIA
    rjmp fin_obtener
    
no_espacio:
    ; Obtener dirección de la letra actual
    ldi  ZH, high(tabla_letras<<1)
    ldi  ZL, low(tabla_letras<<1)
    mov  temp, indice_letra
    lsl  temp                   ; *2 porque son words
    add  ZL, temp
    clr  temp
    adc  ZH, temp
    
    lpm  temp, Z+               ; low del puntero
    lpm  temp2, Z               ; high del puntero
    mov  ZL, temp
    mov  ZH, temp2
    lsl  ZL                     ; word->byte
    rol  ZH
    
    ; Ahora Z apunta al inicio de los datos de la letra
    ; Necesitamos extraer la columna col_letra (bit 7-col_letra de cada fila)
    
    ldi  temp3, 0              ; resultado acumulado
    ldi  temp2, 8              ; contador de filas
    
extraer_columna:
    lpm  temp, Z+              ; cargar byte de la fila
    
    ; Extraer el bit correspondiente a col_letra
    ; col_letra=0 -> bit7, col_letra=1 -> bit6, etc.
    push temp2
    mov  temp2, col_letra
    cpi  temp2, 0
    breq no_shift
    
shift_loop:
    lsl  temp                  ; mover el bit deseado a bit7
    dec  temp2
    brne shift_loop
    
no_shift:
    ; El bit deseado está en bit7
    lsr  temp3                 ; hacer espacio para el nuevo bit
    sbrc temp, 7               ; si bit7 es 1
    ori  temp3, 0x80          ; poner bit7 en el resultado
    
    pop  temp2
    dec  temp2
    brne extraer_columna
    
fin_obtener:
    pop  temp2
    pop  temp
    pop  ZH
    pop  ZL
    ret

; Multiplexar la matriz completa una vez
multiplexar_matriz:
    push fila
    push XL
    push XH
    
    ldi  fila, 0
multiplex_loop:
    ; Cargar columnas de la fila actual desde el buffer
    ldi  XL, low(matriz_buffer)
    ldi  XH, high(matriz_buffer)
    add  XL, fila
    clr  temp
    adc  XH, temp
    ld   columnas, X
    
    ; Mostrar la fila
    rcall cargar_columnas
    rcall seleccionar_fila
    rcall retardo_fila
    rcall apagar_filas
    rcall apagar_columnas
    
    inc  fila
    cpi  fila, 8
    brne multiplex_loop
    
    pop  XH
    pop  XL
    pop  fila
    ret

; Columnas (col1..4 -> PB2..PB5 ; col5..8 -> PC5..PC2)
cargar_columnas:
    ; PB2..PB5 (col1..4 = bits7..4)
    in   temp, PORTB
    andi temp, 0xC3
    clr  temp2

    mov  temp3, columnas        ; bit7 -> PB2
    andi temp3, 0x80
    lsr  temp3
    lsr  temp3
    lsr  temp3
    lsr  temp3
    lsr  temp3
    or   temp2, temp3

    mov  temp3, columnas        ; bit6 -> PB3
    andi temp3, 0x40
    lsr  temp3
    lsr  temp3
    lsr  temp3
    or   temp2, temp3

    mov  temp3, columnas        ; bit5 -> PB4
    andi temp3, 0x20
    lsr  temp3
    or   temp2, temp3

    mov  temp3, columnas        ; bit4 -> PB5
    andi temp3, 0x10
    lsl  temp3
    or   temp2, temp3

    or   temp, temp2
    out  PORTB, temp

    ; PC2..PC5 (col5..8 = bits3..0)
    in   temp, PORTC
    andi temp, 0xC3
    mov  temp2, columnas
    andi temp2, 0x0F
    lsl  temp2
    lsl  temp2
    andi temp2, 0x3C
    or   temp, temp2
    out  PORTC, temp
    ret

; Selección de fila (activo-bajo)
seleccionar_fila:
    rcall apagar_filas
    mov  temp, fila
    cpi  temp, 0x06
    brlo fila_PD

    in   temp2, PORTB
    cpi  temp, 0x06
    breq fila_PB0
    andi temp2, 0xFD            ; PB1=0
    out  PORTB, temp2
    ret
fila_PB0:
    andi temp2, 0xFE            ; PB0=0
    out  PORTB, temp2
    ret

fila_PD:
    ldi  temp2, 0x01
    add  temp, temp2
    add  temp, temp2            ; temp = fila + 2
    in   temp3, PORTD
    ldi  temp4, 0x01
shift_bit:
    dec  temp
    brmi bit_ok
    lsl  temp4
    rjmp shift_bit
bit_ok:
    com  temp4                  ; 0 solo en el bit elegido
    and  temp3, temp4
    out  PORTD, temp3
    ret

; Apagar todas las filas
apagar_filas:
    in   temp, PORTD
    ori  temp, 0xFC
    out  PORTD, temp
    in   temp, PORTB
    ori  temp, 0x03
    out  PORTB, temp
    ret

; Apagar todas las columnas
apagar_columnas:
    in   temp, PORTB
    andi temp, 0xC3
    out  PORTB, temp
    in   temp, PORTC
    andi temp, 0xC3
    out  PORTC, temp
    ret

; Retardo para el brillo de cada fila
retardo_fila:
    push temp
    ldi  temp, 0x80
retardo_lp:
    dec  temp
    brne retardo_lp
    pop  temp
    ret
