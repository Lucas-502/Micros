import argparse, csv, re, sys, threading, time
from datetime import datetime

import matplotlib.pyplot as plt
import serial
from serial.serialutil import SerialException, PortNotOpenError
from serial.tools import list_ports

# CLI args 
ap = argparse.ArgumentParser(description="Grafica temp y envia comandos por UART")
ap.add_argument("--port", required=True, help="Puerto serie (ej: COM6 o /dev/ttyACM0)")
ap.add_argument("--baud", type=int, default=9600, help="Baudrate (def 9600)")
ap.add_argument("--csv", default="log_temp.csv", help="Archivo CSV de salida")
ap.add_argument("--mid", type=int, default=26, help="Punto medio inicial para dibujar banda")
ap.add_argument("--bw",  type=int, default=4,  help="Media-banda inicial para dibujar banda")
args = ap.parse_args()

# Estado local solo grafico
mid = args.mid
bw  = args.bw
_band_dirty = False          #  se actualiza en hilos, la dibuja el hilo principal

# Terminador de línea que espera el firmware (CR+LF)
LINE_END = "\r\n"

# Zonas y parser de la linea de telemetria del firmware:
# ejemplo: "Temp=27 C | ZONE=LOW | OUT=255"
RX_FULL = re.compile(r"Temp=(\d+)\s+C\s+\|\s+ZONE=(\w+)\s+\|\s+OUT=(\d+)")
ZONE_MAP = {"HEAT":0, "OK":1, "LOW":2, "MED":3, "HIGH":4}
FAN_FROM_ZONE = {0:0, 1:0, 2:1, 3:2, 4:3}  # nivel 0..3 para graficar

#  Serial 
def open_serial(port, baud):
    try:
        s = serial.Serial(port, baud, timeout=1)
        time.sleep(2.0)           # UNO suele resetear al abrir el puerto
        s.reset_input_buffer()    # limpia basura del bootloader
        print(f"[OK] Abierto {port} @ {baud}")
        return s
    except Exception as e:
        ports = [p.device for p in list_ports.comports()]
        print(f"[ERR] No pude abrir {port}. Puertos disponibles: {ports}")
        print("Cerrá otros monitores serie y verificá el COM.")
        raise e

try:
    ser = open_serial(args.port, args.baud)
except Exception:
    sys.exit(1)

ser_lock = threading.Lock()

def ser_write_line(line: str):
    """Envia una linea al puerto (si esta abierto) usando CRLF, sin romper el programa."""
    try:
        if ser and ser.is_open:
            with ser_lock:
                ser.write((line + LINE_END).encode("ascii", errors="ignore"))
            print(f"[TX] {line}")
        else:
            print("[WARN] Puerto no abierto. No se envio:", line)
    except (PortNotOpenError, SerialException) as e:
        print("[WARN] No se pudo escribir en el puerto:", e)

#  CSV 
try:
    open(args.csv, "x").write("timestamp,time_s,tempC,zone,out,heater,fan_level,raw\n")
except FileExistsError:
    pass

# Plot 
plt.ion()
fig, ax = plt.subplots()
lineT, = ax.plot([], [], label="Temp [C]")
ax.set_xlabel("Tiempo [s]")
ax.set_ylabel("Temp [C]")
ax.grid(True)

# Banda mid±bw que actualizamos cuando cambian mid/bw
band = ax.axhspan(mid-bw, mid+bw, alpha=0.15, label="Rango ideal (mid±bw)")

ax2 = ax.twinx()
lineF, = ax2.plot([], [], linestyle="--", label="Nivel Fan (0..3)")
ax2.set_ylabel("Nivel Fan")
ax2.set_ylim(-0.2, 3.2)

lines = [lineT, lineF]
ax.legend(lines, [l.get_label() for l in lines], loc="upper left")

xs, Ts, Fs = [], [], []
t0 = time.time()

def update_band():
    global band
    try:
        band.remove()
    except Exception:
        pass
    # recrea el parche con los nuevos mid/bw
    band = ax.axhspan(mid-bw, mid+bw, alpha=0.15)
    fig.canvas.draw_idle()

print("""
[LISTO] Escribí comandos en esta ventana y ENTER:
  HO/HF/HA | FL/FM/FH/FF/FA | M=26 | BW=4 | S | H
  Atajos: 'mid 26', 'bw 4', 'rng 23 30' (calcula mid y bw)
  Hotkeys en la ventana del gráfico: ]/[ suben/bajan MID · }/{ suben/bajan BW
  h: HA · f: FA · 0/1/2/3: Fan OFF/LOW/MED/HIGH · s: STATUS
  Cortar: Ctrl+C
""".strip())
