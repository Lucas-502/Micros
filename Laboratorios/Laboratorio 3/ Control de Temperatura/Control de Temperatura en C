#define F_CPU 16000000UL
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>

//  UART 9600 8N1 
#define BAUD 9600UL
#define UBRR_VAL ((F_CPU/(16UL*BAUD))-1)

static inline void uart_init(void) {
    UBRR0H = (uint8_t)(UBRR_VAL >> 8);
    UBRR0L = (uint8_t)(UBRR_VAL);
    UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    UCSR0C = (1<<UCSZ01)|(1<<UCSZ00); // 8N1
}
static inline void uart_putc(char c) {
    while(!(UCSR0A & (1<<UDRE0)));
    UDR0 = c;
}
static void uart_puts(const char *s) {
    while(*s) uart_putc(*s++);
}
// impresores sin itoa()
static void uart_u16(uint16_t v){
    char buf[6]; uint8_t i=0;
    do{ buf[i++] = (char)('0' + (v % 10)); v /= 10; }while(v);
    while(i--) uart_putc(buf[i]);
}
static void uart_i16(int16_t v){
    if(v < 0){ uart_putc('-'); v = (int16_t)(-v); }
    uart_u16((uint16_t)v);
}
static void uart_u8(uint8_t v){ uart_u16(v); }

volatile uint32_t ms = 0;
ISR(TIMER0_COMPA_vect){ ms++; }

static void t0_init_1ms(void){
    TCCR0A = (1<<WGM01);          // CTC
    TCCR0B = 0;
    OCR0A  = 249;                 // 16 MHz / 64 / (249+1) = 1000 Hz
    TIMSK0 = (1<<OCIE0A);
    TCCR0B = (1<<CS01)|(1<<CS00); // prescaler 64
}

// ADC LM35 
static void adc_init(void){
    ADMUX  = (1<<REFS0);                  // AVcc ref, ADC0 (MUX=0000)
    ADCSRA = (1<<ADEN) | (1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); // presc 128
}
static uint16_t adc_read(void){
    ADCSRA |= (1<<ADSC);
    while(ADCSRA & (1<<ADSC));
    return ADC;
}
static int16_t lm35_read_celsius(void){
    // promedio de 8 lecturas + redondeo a °C (10 mV/°C)
    uint32_t acc=0;
    for(uint8_t i=0;i<8;i++){ acc += adc_read(); _delay_ms(2); }
    uint16_t adc = (uint16_t)(acc/8);
    uint32_t mV  = (uint32_t)adc * 5000UL / 1023UL;
    int16_t tC   = (int16_t)((mV + 5) / 10);
    return tC;
}

//HW heater & fan
static inline void heater_on(void){  PORTD |=  (1<<PD5); }
static inline void heater_off(void){ PORTD &= ~(1<<PD5); }
//IN2 (PB5) LOW fijo. IN1 (PB2) conmuta
static uint8_t last_out = 0;
static void fan_out(uint8_t val){
    if(val == 0){
        PORTB &= ~(1<<PB2);  // IN1=0
        last_out = 0;
        return;
    }
    if(last_out == 0){
        PORTB |=  (1<<PB2);  // patada inicial
        _delay_ms(180);
    }
    PORTB |= (1<<PB2);       // mantener ON
    last_out = 255;
}

// Ráfagas (burst) 
static bool     burst_enabled = false;
static bool     burst_on      = false;
static uint16_t ton_ms = 0, toff_ms = 0;
static uint32_t burst_next_ms = 0;

static void fan_set_burst(uint16_t ton, uint16_t period){
    if(ton > period) ton = period;
    ton_ms  = ton;
    toff_ms = period - ton;
    if(ton_ms == 0 || period == 0){
        burst_enabled = false;
        burst_on      = false;
        fan_out(0);
        return;
    }
    burst_enabled = true;
    burst_on      = true;
    fan_out(255);
    burst_next_ms = ms + ton_ms;
}
static void fan_set_high_continuous(void){
    burst_enabled = false;
    burst_on      = true;
    fan_out(255);
}
static void fan_update(void){
    if(!burst_enabled) return;
    if((int32_t)(ms - burst_next_ms) >= 0){
        burst_on = !burst_on;
        fan_out(burst_on ? 255 : 0);
        burst_next_ms = ms + (burst_on ? ton_ms : toff_ms);
    }
}
