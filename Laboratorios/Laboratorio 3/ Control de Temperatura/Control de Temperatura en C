#define F_CPU 16000000UL
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>

//  UART 9600 8N1 
#define BAUD 9600UL
#define UBRR_VAL ((F_CPU/(16UL*BAUD))-1)

static inline void uart_init(void) {
    UBRR0H = (uint8_t)(UBRR_VAL >> 8);
    UBRR0L = (uint8_t)(UBRR_VAL);
    UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    UCSR0C = (1<<UCSZ01)|(1<<UCSZ00); // 8N1
}
static inline void uart_putc(char c) {
    while(!(UCSR0A & (1<<UDRE0)));
    UDR0 = c;
}
static void uart_puts(const char *s) {
    while(*s) uart_putc(*s++);
}
// impresores sin itoa()
static void uart_u16(uint16_t v){
    char buf[6]; uint8_t i=0;
    do{ buf[i++] = (char)('0' + (v % 10)); v /= 10; }while(v);
    while(i--) uart_putc(buf[i]);
}
static void uart_i16(int16_t v){
    if(v < 0){ uart_putc('-'); v = (int16_t)(-v); }
    uart_u16((uint16_t)v);
}
static void uart_u8(uint8_t v){ uart_u16(v); }

volatile uint32_t ms = 0;
ISR(TIMER0_COMPA_vect){ ms++; }

static void t0_init_1ms(void){
    TCCR0A = (1<<WGM01);          // CTC
    TCCR0B = 0;
    OCR0A  = 249;                 // 16 MHz / 64 / (249+1) = 1000 Hz
    TIMSK0 = (1<<OCIE0A);
    TCCR0B = (1<<CS01)|(1<<CS00); // prescaler 64
}

// ADC LM35 
static void adc_init(void){
    ADMUX  = (1<<REFS0);                  // AVcc ref, ADC0 (MUX=0000)
    ADCSRA = (1<<ADEN) | (1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); // presc 128
}
static uint16_t adc_read(void){
    ADCSRA |= (1<<ADSC);
    while(ADCSRA & (1<<ADSC));
    return ADC;
}
static int16_t lm35_read_celsius(void){
    // promedio de 8 lecturas + redondeo a °C (10 mV/°C)
    uint32_t acc=0;
    for(uint8_t i=0;i<8;i++){ acc += adc_read(); _delay_ms(2); }
    uint16_t adc = (uint16_t)(acc/8);
    uint32_t mV  = (uint32_t)adc * 5000UL / 1023UL;
    int16_t tC   = (int16_t)((mV + 5) / 10);
    return tC;
}

//HW heater & fan
static inline void heater_on(void){  PORTD |=  (1<<PD5); }
static inline void heater_off(void){ PORTD &= ~(1<<PD5); }
//IN2 (PB5) LOW fijo. IN1 (PB2) conmuta
static uint8_t last_out = 0;
static void fan_out(uint8_t val){
    if(val == 0){
        PORTB &= ~(1<<PB2);  // IN1=0
        last_out = 0;
        return;
    }
    if(last_out == 0){
        PORTB |=  (1<<PB2);  // patada inicial
        _delay_ms(180);
    }
    PORTB |= (1<<PB2);       // mantener ON
    last_out = 255;
}

// Ráfagas (burst) 
static bool     burst_enabled = false;
static bool     burst_on      = false;
static uint16_t ton_ms = 0, toff_ms = 0;
static uint32_t burst_next_ms = 0;

static void fan_set_burst(uint16_t ton, uint16_t period){
    if(ton > period) ton = period;
    ton_ms  = ton;
    toff_ms = period - ton;
    if(ton_ms == 0 || period == 0){
        burst_enabled = false;
        burst_on      = false;
        fan_out(0);
        return;
    }
    burst_enabled = true;
    burst_on      = true;
    fan_out(255);
    burst_next_ms = ms + ton_ms;
}
static void fan_set_high_continuous(void){
    burst_enabled = false;
    burst_on      = true;
    fan_out(255);
}
static void fan_update(void){
    if(!burst_enabled) return;
    if((int32_t)(ms - burst_next_ms) >= 0){
        burst_on = !burst_on;
        fan_out(burst_on ? 255 : 0);
        burst_next_ms = ms + (burst_on ? ton_ms : toff_ms);
    }
}

//Modos y setpoint
typedef enum { H_AUTO, H_ON, H_OFF } HeaterMode;
typedef enum { F_AUTO, F_OFF, F_LOW, F_MED, F_HIGH } FanMode;

static HeaterMode hmode = H_AUTO;
static FanMode    fmode = F_AUTO;

static int16_t mid = 26;  // punto medio (°C)
static int16_t bw  = 4;   // media-banda (°C)
#define STEP 4            // escalón para LOW/MED/HIGH
static uint16_t BURST_MS   = 500;
static uint16_t TON_LOW_MS = 220;
static uint16_t TON_MED_MS = 320;

// T→zona (0=HEAT,1=OK,2=LOW,3=MED,4=HIGH)
static uint8_t zone_from_temp(int16_t T){
    int16_t ok_lo = mid - bw;
    int16_t ok_hi = mid + bw;
    if      (T <= ok_lo - 1)       return 0; // HEAT
    else if (T <= ok_hi)           return 1; // OK
    else if (T <= ok_hi + STEP)    return 2; // LOW
    else if (T <= ok_hi + 2*STEP)  return 3; // MED
    else                           return 4; // HIGH
}


// UART parser (línea CR/LF) + helpers 
static char rxline[64];
static uint8_t rxpos = 0;

static void print_help(void){
    uart_puts("Cmd: HO/HF/HA | FF/FL/FM/FH/FA | M=<n>|MID <n> | BW=<n>|BW <n> | S\r\n");
}
static void ack_mid_bw(const char* what){
    uart_puts("ACK "); uart_puts(what); uart_puts(" OK[");
    uart_i16(mid-bw); uart_puts(".."); uart_i16(mid+bw); uart_puts("]\r\n");
}
// parser simple de enteros con signo; 1 si ok 
static uint8_t parse_int16(const char *p, int16_t *out){
    while(*p==' ' || *p=='=') p++;
    int neg = 0; int32_t acc = 0; uint8_t have=0;
    if(*p=='+' || *p=='-'){ neg = (*p=='-'); p++; }
    while(*p>='0' && *p<='9'){
        acc = acc*10 + (*p - '0');
        p++; have=1;
        if(acc > 32767) acc = 32767;
    }
    if(!have) return 0;
    *out = (int16_t)(neg ? -acc : acc);
    return 1;
}

// Decodificador de comandos 
static void handle_line(char *line){
    for(char *p=line; *p; ++p) *p = (char)toupper((unsigned char)*p);
    while(*line==' ') line++;
    char *e = line + strlen(line);
    while(e>line && (e[-1]==' '||e[-1]=='\r'||e[-1]=='\n')) *--e = 0;
    if(!*line) return;

    if(!strcmp(line,"HO")){ hmode=H_ON;  uart_puts("Heater=ON\r\n");  return; }
    if(!strcmp(line,"HF")){ hmode=H_OFF; uart_puts("Heater=OFF\r\n"); return; }
    if(!strcmp(line,"HA")){ hmode=H_AUTO;uart_puts("Heater=AUTO\r\n");return; }

    if(!strcmp(line,"FF")){ fmode=F_OFF;  uart_puts("Fan=OFF\r\n");  return; }
    if(!strcmp(line,"FL")){ fmode=F_LOW;  uart_puts("Fan=LOW\r\n");  return; }
    if(!strcmp(line,"FM")){ fmode=F_MED;  uart_puts("Fan=MED\r\n");  return; }
    if(!strcmp(line,"FH")){ fmode=F_HIGH; uart_puts("Fan=HIGH\r\n"); return; }
    if(!strcmp(line,"FA")){ fmode=F_AUTO; uart_puts("Fan=AUTO\r\n"); return; }


    if(!strcmp(line,"S")){
        uart_puts("STATUS mid="); uart_i16(mid);
        uart_puts(" bw=");        uart_i16(bw);
        uart_puts(" OK[");        uart_i16(mid-bw);
        uart_puts("..");          uart_i16(mid+bw);
        uart_puts("]\r\n");
        return;
    }
    if(!strcmp(line,"H")){ print_help(); return; }

    if(line[0]=='M'){
        const char *p = line+1;
        if(p[0]=='I' && p[1]=='D') p+=2;   // admite MID
        int16_t v;
        if(parse_int16(p,&v)){ mid=v; ack_mid_bw("M"); return; }
    }
    if(line[0]=='B' && line[1]=='W'){
        const char *p = line+2;
        int16_t v;
        if(parse_int16(p,&v)){ bw=v; ack_mid_bw("BW"); return; }
    }
    uart_puts("ERR cmd: "); uart_puts(line); uart_puts("\r\n");
}

