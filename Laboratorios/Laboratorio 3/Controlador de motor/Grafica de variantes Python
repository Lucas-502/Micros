PORT = None            
BAUD = 115200
READ_TIMEOUT_S = 0.05
WINDOW_SAMPLES = 800
SAVE_CSV = False

from serial.tools import list_ports
import serial, time, csv, datetime
from collections import deque
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

def pick_port(user_port: str | None):
    ports = list(list_ports.comports())
    if user_port:
        return user_port, ports
    prefer = []
    for p in ports:
        desc = f"{p.description} {p.hwid}".lower()
        score = 0
        if "arduino" in desc: score += 3
        if "ch340"  in desc or "wchusb" in desc: score += 2
        if "ftdi"   in desc: score += 2
        if "usb"    in desc: score += 1
        prefer.append((score, p.device, p.description))
    if not prefer:
        raise RuntimeError("No se encontró ningún puerto serie. Conectá el Arduino.")
    prefer.sort(reverse=True)
    return prefer[0][1], ports

def open_serial(port, baud, timeout):
    dev, ports = pick_port(port)
    print("[INFO] Puertos detectados:")
    for p in ports:
        print(f"  - {p.device:>6}  {p.description}")
    print(f"[INFO] Intentando abrir: {dev} @ {baud}")
    try:
        ser = serial.Serial(dev, baudrate=baud, timeout=timeout)
        try:
            ser.dtr = False
            ser.rts = False
            time.sleep(0.3)
        except Exception:
            pass
        ser.reset_input_buffer()
        return ser, dev
    except Exception as e:
        raise SystemExit(f"[ERROR] No pude abrir el puerto {dev}: {e}\n"
                         "Cerrá el Monitor Serie del IDE y probá de nuevo.")

def dir_to_txt(d):
    try:
        d = int(d)
    except:
        return "?"
    return "DER" if d > 0 else ("IZQ" if d < 0 else "PARADO")

def now_str():
    return datetime.datetime.now().strftime("%H:%M:%S")

def opcion_1_graficas_en_vivo():
    ser, used_port = open_serial(PORT, BAUD, READ_TIMEOUT_S)

    t_ms   = deque(maxlen=WINDOW_SAMPLES)
    sp     = deque(maxlen=WINDOW_SAMPLES)
    pv     = deque(maxlen=WINDOW_SAMPLES)
    pwm    = deque(maxlen=WINDOW_SAMPLES)
    rows   = deque(maxlen=200)

    csv_writer = None
    csv_file = None
    if SAVE_CSV:
        fname = f"log_motor_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        csv_file = open(fname, "w", newline="")
        csv_writer = csv.writer(csv_file)
        csv_writer.writerow(["iso_time","t_ms","SP","PV","PWM","DIR","BOOST"])

    fig = plt.figure(figsize=(10, 5))
    gs = fig.add_gridspec(1, 2, width_ratios=[3, 2], wspace=0.25)
    ax = fig.add_subplot(gs[0, 0])
    ax_text = fig.add_subplot(gs[0, 1]); ax_text.axis("off")

    (line_sp,)  = ax.plot([], [], label="SP")
    (line_pv,)  = ax.plot([], [], label="PV")
    (line_pwm,) = ax.plot([], [], label="PWM×4")

    ax.set_title(f"SP / PV / PWM (tiempo real)  —  {used_port} @ {BAUD}")
    ax.set_xlabel("muestras recientes"); ax.set_ylabel("valor (0..1023)")
    ax.set_ylim(0, 1023); ax.legend(loc="upper right")

    buf = b""

    def parse_line(s):
        parts = s.strip().split(",")
        if len(parts) != 6:
            if s:
                print(f"[RAW@{used_port}] {s}")
            return None
        try:
            t  = int(parts[0]); spv = int(parts[1]); pvv = int(parts[2])
            pw = int(parts[3]); di  = int(parts[4]); bo  = int(parts[5])
            return t, spv, pvv, pw, di, bo
        except Exception:
            print(f"[BADFMT@{used_port}] {s}")
            return None

    def update(_):
        nonlocal buf
        try:
            incoming = ser.read(4096)
        except serial.SerialException as e:
            ax_text.clear(); ax_text.axis("off")
            ax_text.text(0, 1, f"[{now_str()}] ERROR puerto: {e}", va="top", family="monospace")
            return line_sp, line_pv, line_pwm

        if incoming:
            buf += incoming
            while b"\n" in buf:
                line, buf = buf.split(b"\n", 1)
                s = line.decode(errors="ignore").strip()
                if not s or s.startswith("t_ms"):
                    continue
                parsed = parse_line(s)
                if not parsed:
                    continue
                t, spv, pvv, pw, di, bo = parsed
                t_ms.append(t); sp.append(spv); pv.append(pvv); pwm.append(pw)

                if csv_writer:
                    csv_writer.writerow([datetime.datetime.now().isoformat(), t, spv, pvv, pw, di, bo])

                rows.appendleft(
                    f"[{now_str()}] t={t:6d}  SP={spv:4d}  PV={pvv:4d}  PWM={pw:3d}  DIR={dir_to_txt(di):6s}  BOOST={bo}"
                )

        n = len(sp); xs = list(range(max(0, n - WINDOW_SAMPLES), n))
        ys_sp = list(sp)[-len(xs):]; ys_pv = list(pv)[-len(xs):]
        ys_pwm4 = [v * 4 for v in list(pwm)[-len(xs):]]

        line_sp.set_data(xs, ys_sp); line_pv.set_data(xs, ys_pv); line_pwm.set_data(xs, ys_pwm4)
        ax.set_xlim(xs[0] if xs else 0, xs[-1] if xs else 1)

        ax_text.clear(); ax_text.axis("off")
        snippet = "\n".join(list(rows)[:25]) if rows else "Esperando datos...\nRecordá: t_ms,SP,PV,PWM,DIR,BOOST"
        ax_text.text(0, 1, snippet, va="top", family="monospace")

        return line_sp, line_pv, line_pwm

