#ifndef F_CPU
#define F_CPU 16000000UL
#endif
#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>

//UART 115200
static void uart_init(uint32_t b){
    uint16_t u = (uint16_t)(F_CPU/(8UL*b) - 1UL);  
    UBRR0H = (uint8_t)(u >> 8);
    UBRR0L = (uint8_t)(u & 0xFF);
    UCSR0A = (1<<U2X0);                  
    UCSR0B = (1<<TXEN0);                
    UCSR0C = (1<<UCSZ01) | (1<<UCSZ00);  
}

//TX
static inline void pch(char c){ while(!(UCSR0A & (1<<UDRE0))); UDR0 = c; }
static void ps(const char *s){ while(*s) pch(*s++); }
static void pu32(uint32_t v){
    char b[11]; int i = 10; b[i] = 0;
    if(!v){ pch('0'); return; }
    while(v && i){ b[--i] = '0' + (v % 10U); v /= 10U; }
    ps(&b[i]);
}
static void pi16(int16_t v){
    if(v < 0){ pch('-'); v = -v; }
    char b[7]; int i = 6; b[i] = 0;
    if(!v){ pch('0'); return; }
    while(v && i){ b[--i] = '0' + (v % 10); v /= 10; }
    ps(&b[i]);
}

//ADC
static void adc_init(void){ ADMUX=(1<<REFS0); ADCSRA=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); }
static uint16_t adc_read(uint8_t ch){ ADMUX=(ADMUX&0xF0)|(ch&0x0F); ADCSRA|=(1<<ADSC); while(ADCSRA&(1<<ADSC)); return ADC; }

//PWM
static void pwm_init(void){ DDRB|=(1<<PB1); TCCR1A=(1<<WGM10)|(1<<COM1A1); TCCR1B=(1<<WGM12)|(1<<CS11); OCR1A=0; }
static inline void pwm_set(uint8_t v){ OCR1A=v; }

//L293N
static void gpio_init(void){ DDRD|=(1<<PD7); DDRB|=(1<<PB0); }
static inline void motor_coast(void){ PORTD&=~(1<<PD7); PORTB&=~(1<<PB0); }
static inline void motor_brake(void){ PORTD|=(1<<PD7);  PORTB|=(1<<PB0); }
static inline void motor_fwd(void){   PORTD|=(1<<PD7);  PORTB&=~(1<<PB0); }
static inline void motor_rev(void){   PORTD&=~(1<<PD7); PORTB|=(1<<PB0); }

//CONTROL
#define LOOP_MS        10
#define AVG_N           8

//Ganancias
#define KP_NUM          2
#define KP_DEN         10
#define KI_NUM          1
#define KI_DEN         50

//Par y lÃ­mites
#define U_STATIC       80
#define U_MIN          95
#define U_MAX         255

//Cap global
#define TOP_PWM_CAP   130

//Zonas cerca del setpoint
#define CREEP_BAND     35
#define CREEP_PWM      90
#define HOLD_BAND      20   
#define HOLD_PWM       75
#define DEAD_BAND       3   

#define SLEW_UP         1   
#define SLEW_DOWN       4

#define PV_STALL_DELTA  2
#define STALL_TICKS    15
#define BOOST_PWM     200
#define BOOST_MS       80

#define DITHER_PWM      10
#define DITHER_PERIOD    4

static int16_t avg_upd(int16_t *buf, uint8_t n, uint8_t *idx, int16_t x){
    buf[*idx]=x; int32_t s=0; for(uint8_t i=0;i<n;i++) s+=buf[i];
    *idx=(uint8_t)((*idx+1)%n); return (int16_t)(s/n);
}
